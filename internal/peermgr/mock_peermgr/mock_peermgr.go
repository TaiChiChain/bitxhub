// Code generated by MockGen. DO NOT EDIT.
// Source: peermgr.go
//
// Generated by this command:
//
//	mockgen -destination mock_peermgr/mock_peermgr.go -package mock_peermgr -source peermgr.go -typed
//
// Package mock_peermgr is a generated GoMock package.
package mock_peermgr

import (
	context "context"
	reflect "reflect"

	pb "github.com/axiomesh/axiom-kit/types/pb"
	network "github.com/axiomesh/axiom-p2p"
	peer "github.com/libp2p/go-libp2p/core/peer"
	gomock "go.uber.org/mock/gomock"
)

// MockBasicPeerManager is a mock of BasicPeerManager interface.
type MockBasicPeerManager struct {
	ctrl     *gomock.Controller
	recorder *MockBasicPeerManagerMockRecorder
}

// MockBasicPeerManagerMockRecorder is the mock recorder for MockBasicPeerManager.
type MockBasicPeerManagerMockRecorder struct {
	mock *MockBasicPeerManager
}

// NewMockBasicPeerManager creates a new mock instance.
func NewMockBasicPeerManager(ctrl *gomock.Controller) *MockBasicPeerManager {
	mock := &MockBasicPeerManager{ctrl: ctrl}
	mock.recorder = &MockBasicPeerManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBasicPeerManager) EXPECT() *MockBasicPeerManagerMockRecorder {
	return m.recorder
}

// CountConnectedPeers mocks base method.
func (m *MockBasicPeerManager) CountConnectedPeers() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountConnectedPeers")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// CountConnectedPeers indicates an expected call of CountConnectedPeers.
func (mr *MockBasicPeerManagerMockRecorder) CountConnectedPeers() *BasicPeerManagerCountConnectedPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountConnectedPeers", reflect.TypeOf((*MockBasicPeerManager)(nil).CountConnectedPeers))
	return &BasicPeerManagerCountConnectedPeersCall{Call: call}
}

// BasicPeerManagerCountConnectedPeersCall wrap *gomock.Call
type BasicPeerManagerCountConnectedPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerCountConnectedPeersCall) Return(arg0 uint64) *BasicPeerManagerCountConnectedPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerCountConnectedPeersCall) Do(f func() uint64) *BasicPeerManagerCountConnectedPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerCountConnectedPeersCall) DoAndReturn(f func() uint64) *BasicPeerManagerCountConnectedPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PeerID mocks base method.
func (m *MockBasicPeerManager) PeerID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeerID")
	ret0, _ := ret[0].(string)
	return ret0
}

// PeerID indicates an expected call of PeerID.
func (mr *MockBasicPeerManagerMockRecorder) PeerID() *BasicPeerManagerPeerIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeerID", reflect.TypeOf((*MockBasicPeerManager)(nil).PeerID))
	return &BasicPeerManagerPeerIDCall{Call: call}
}

// BasicPeerManagerPeerIDCall wrap *gomock.Call
type BasicPeerManagerPeerIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerPeerIDCall) Return(arg0 string) *BasicPeerManagerPeerIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerPeerIDCall) Do(f func() string) *BasicPeerManagerPeerIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerPeerIDCall) DoAndReturn(f func() string) *BasicPeerManagerPeerIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Peers mocks base method.
func (m *MockBasicPeerManager) Peers() []peer.AddrInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peers")
	ret0, _ := ret[0].([]peer.AddrInfo)
	return ret0
}

// Peers indicates an expected call of Peers.
func (mr *MockBasicPeerManagerMockRecorder) Peers() *BasicPeerManagerPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peers", reflect.TypeOf((*MockBasicPeerManager)(nil).Peers))
	return &BasicPeerManagerPeersCall{Call: call}
}

// BasicPeerManagerPeersCall wrap *gomock.Call
type BasicPeerManagerPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerPeersCall) Return(arg0 []peer.AddrInfo) *BasicPeerManagerPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerPeersCall) Do(f func() []peer.AddrInfo) *BasicPeerManagerPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerPeersCall) DoAndReturn(f func() []peer.AddrInfo) *BasicPeerManagerPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Send mocks base method.
func (m *MockBasicPeerManager) Send(arg0 string, arg1 *pb.Message) (*pb.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", arg0, arg1)
	ret0, _ := ret[0].(*pb.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Send indicates an expected call of Send.
func (mr *MockBasicPeerManagerMockRecorder) Send(arg0, arg1 any) *BasicPeerManagerSendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockBasicPeerManager)(nil).Send), arg0, arg1)
	return &BasicPeerManagerSendCall{Call: call}
}

// BasicPeerManagerSendCall wrap *gomock.Call
type BasicPeerManagerSendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerSendCall) Return(arg0 *pb.Message, arg1 error) *BasicPeerManagerSendCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerSendCall) Do(f func(string, *pb.Message) (*pb.Message, error)) *BasicPeerManagerSendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerSendCall) DoAndReturn(f func(string, *pb.Message) (*pb.Message, error)) *BasicPeerManagerSendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendWithStream mocks base method.
func (m *MockBasicPeerManager) SendWithStream(arg0 network.Stream, arg1 *pb.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendWithStream", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendWithStream indicates an expected call of SendWithStream.
func (mr *MockBasicPeerManagerMockRecorder) SendWithStream(arg0, arg1 any) *BasicPeerManagerSendWithStreamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendWithStream", reflect.TypeOf((*MockBasicPeerManager)(nil).SendWithStream), arg0, arg1)
	return &BasicPeerManagerSendWithStreamCall{Call: call}
}

// BasicPeerManagerSendWithStreamCall wrap *gomock.Call
type BasicPeerManagerSendWithStreamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerSendWithStreamCall) Return(arg0 error) *BasicPeerManagerSendWithStreamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerSendWithStreamCall) Do(f func(network.Stream, *pb.Message) error) *BasicPeerManagerSendWithStreamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerSendWithStreamCall) DoAndReturn(f func(network.Stream, *pb.Message) error) *BasicPeerManagerSendWithStreamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockBasicPeerManager) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockBasicPeerManagerMockRecorder) Start() *BasicPeerManagerStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockBasicPeerManager)(nil).Start))
	return &BasicPeerManagerStartCall{Call: call}
}

// BasicPeerManagerStartCall wrap *gomock.Call
type BasicPeerManagerStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerStartCall) Return(arg0 error) *BasicPeerManagerStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerStartCall) Do(f func() error) *BasicPeerManagerStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerStartCall) DoAndReturn(f func() error) *BasicPeerManagerStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockBasicPeerManager) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockBasicPeerManagerMockRecorder) Stop() *BasicPeerManagerStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockBasicPeerManager)(nil).Stop))
	return &BasicPeerManagerStopCall{Call: call}
}

// BasicPeerManagerStopCall wrap *gomock.Call
type BasicPeerManagerStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *BasicPeerManagerStopCall) Return(arg0 error) *BasicPeerManagerStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *BasicPeerManagerStopCall) Do(f func() error) *BasicPeerManagerStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *BasicPeerManagerStopCall) DoAndReturn(f func() error) *BasicPeerManagerStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPipe is a mock of Pipe interface.
type MockPipe struct {
	ctrl     *gomock.Controller
	recorder *MockPipeMockRecorder
}

// MockPipeMockRecorder is the mock recorder for MockPipe.
type MockPipeMockRecorder struct {
	mock *MockPipe
}

// NewMockPipe creates a new mock instance.
func NewMockPipe(ctrl *gomock.Controller) *MockPipe {
	mock := &MockPipe{ctrl: ctrl}
	mock.recorder = &MockPipeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPipe) EXPECT() *MockPipeMockRecorder {
	return m.recorder
}

// Broadcast mocks base method.
func (m *MockPipe) Broadcast(ctx context.Context, targets []string, data []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Broadcast", ctx, targets, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Broadcast indicates an expected call of Broadcast.
func (mr *MockPipeMockRecorder) Broadcast(ctx, targets, data any) *PipeBroadcastCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Broadcast", reflect.TypeOf((*MockPipe)(nil).Broadcast), ctx, targets, data)
	return &PipeBroadcastCall{Call: call}
}

// PipeBroadcastCall wrap *gomock.Call
type PipeBroadcastCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PipeBroadcastCall) Return(arg0 error) *PipeBroadcastCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PipeBroadcastCall) Do(f func(context.Context, []string, []byte) error) *PipeBroadcastCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PipeBroadcastCall) DoAndReturn(f func(context.Context, []string, []byte) error) *PipeBroadcastCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Receive mocks base method.
func (m *MockPipe) Receive(ctx context.Context) *network.PipeMsg {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive", ctx)
	ret0, _ := ret[0].(*network.PipeMsg)
	return ret0
}

// Receive indicates an expected call of Receive.
func (mr *MockPipeMockRecorder) Receive(ctx any) *PipeReceiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockPipe)(nil).Receive), ctx)
	return &PipeReceiveCall{Call: call}
}

// PipeReceiveCall wrap *gomock.Call
type PipeReceiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PipeReceiveCall) Return(arg0 *network.PipeMsg) *PipeReceiveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PipeReceiveCall) Do(f func(context.Context) *network.PipeMsg) *PipeReceiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PipeReceiveCall) DoAndReturn(f func(context.Context) *network.PipeMsg) *PipeReceiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Send mocks base method.
func (m *MockPipe) Send(ctx context.Context, to string, data []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", ctx, to, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send.
func (mr *MockPipeMockRecorder) Send(ctx, to, data any) *PipeSendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockPipe)(nil).Send), ctx, to, data)
	return &PipeSendCall{Call: call}
}

// PipeSendCall wrap *gomock.Call
type PipeSendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PipeSendCall) Return(arg0 error) *PipeSendCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PipeSendCall) Do(f func(context.Context, string, []byte) error) *PipeSendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PipeSendCall) DoAndReturn(f func(context.Context, string, []byte) error) *PipeSendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// String mocks base method.
func (m *MockPipe) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockPipeMockRecorder) String() *PipeStringCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockPipe)(nil).String))
	return &PipeStringCall{Call: call}
}

// PipeStringCall wrap *gomock.Call
type PipeStringCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PipeStringCall) Return(arg0 string) *PipeStringCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PipeStringCall) Do(f func() string) *PipeStringCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PipeStringCall) DoAndReturn(f func() string) *PipeStringCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockPeerManager is a mock of PeerManager interface.
type MockPeerManager struct {
	ctrl     *gomock.Controller
	recorder *MockPeerManagerMockRecorder
}

// MockPeerManagerMockRecorder is the mock recorder for MockPeerManager.
type MockPeerManagerMockRecorder struct {
	mock *MockPeerManager
}

// NewMockPeerManager creates a new mock instance.
func NewMockPeerManager(ctrl *gomock.Controller) *MockPeerManager {
	mock := &MockPeerManager{ctrl: ctrl}
	mock.recorder = &MockPeerManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPeerManager) EXPECT() *MockPeerManagerMockRecorder {
	return m.recorder
}

// CountConnectedPeers mocks base method.
func (m *MockPeerManager) CountConnectedPeers() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountConnectedPeers")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// CountConnectedPeers indicates an expected call of CountConnectedPeers.
func (mr *MockPeerManagerMockRecorder) CountConnectedPeers() *PeerManagerCountConnectedPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountConnectedPeers", reflect.TypeOf((*MockPeerManager)(nil).CountConnectedPeers))
	return &PeerManagerCountConnectedPeersCall{Call: call}
}

// PeerManagerCountConnectedPeersCall wrap *gomock.Call
type PeerManagerCountConnectedPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerCountConnectedPeersCall) Return(arg0 uint64) *PeerManagerCountConnectedPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerCountConnectedPeersCall) Do(f func() uint64) *PeerManagerCountConnectedPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerCountConnectedPeersCall) DoAndReturn(f func() uint64) *PeerManagerCountConnectedPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreatePipe mocks base method.
func (m *MockPeerManager) CreatePipe(ctx context.Context, pipeID string) (network.Pipe, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreatePipe", ctx, pipeID)
	ret0, _ := ret[0].(network.Pipe)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreatePipe indicates an expected call of CreatePipe.
func (mr *MockPeerManagerMockRecorder) CreatePipe(ctx, pipeID any) *PeerManagerCreatePipeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePipe", reflect.TypeOf((*MockPeerManager)(nil).CreatePipe), ctx, pipeID)
	return &PeerManagerCreatePipeCall{Call: call}
}

// PeerManagerCreatePipeCall wrap *gomock.Call
type PeerManagerCreatePipeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerCreatePipeCall) Return(arg0 network.Pipe, arg1 error) *PeerManagerCreatePipeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerCreatePipeCall) Do(f func(context.Context, string) (network.Pipe, error)) *PeerManagerCreatePipeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerCreatePipeCall) DoAndReturn(f func(context.Context, string) (network.Pipe, error)) *PeerManagerCreatePipeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PeerID mocks base method.
func (m *MockPeerManager) PeerID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeerID")
	ret0, _ := ret[0].(string)
	return ret0
}

// PeerID indicates an expected call of PeerID.
func (mr *MockPeerManagerMockRecorder) PeerID() *PeerManagerPeerIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeerID", reflect.TypeOf((*MockPeerManager)(nil).PeerID))
	return &PeerManagerPeerIDCall{Call: call}
}

// PeerManagerPeerIDCall wrap *gomock.Call
type PeerManagerPeerIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerPeerIDCall) Return(arg0 string) *PeerManagerPeerIDCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerPeerIDCall) Do(f func() string) *PeerManagerPeerIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerPeerIDCall) DoAndReturn(f func() string) *PeerManagerPeerIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Peers mocks base method.
func (m *MockPeerManager) Peers() []peer.AddrInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peers")
	ret0, _ := ret[0].([]peer.AddrInfo)
	return ret0
}

// Peers indicates an expected call of Peers.
func (mr *MockPeerManagerMockRecorder) Peers() *PeerManagerPeersCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peers", reflect.TypeOf((*MockPeerManager)(nil).Peers))
	return &PeerManagerPeersCall{Call: call}
}

// PeerManagerPeersCall wrap *gomock.Call
type PeerManagerPeersCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerPeersCall) Return(arg0 []peer.AddrInfo) *PeerManagerPeersCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerPeersCall) Do(f func() []peer.AddrInfo) *PeerManagerPeersCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerPeersCall) DoAndReturn(f func() []peer.AddrInfo) *PeerManagerPeersCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Send mocks base method.
func (m *MockPeerManager) Send(arg0 string, arg1 *pb.Message) (*pb.Message, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", arg0, arg1)
	ret0, _ := ret[0].(*pb.Message)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Send indicates an expected call of Send.
func (mr *MockPeerManagerMockRecorder) Send(arg0, arg1 any) *PeerManagerSendCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockPeerManager)(nil).Send), arg0, arg1)
	return &PeerManagerSendCall{Call: call}
}

// PeerManagerSendCall wrap *gomock.Call
type PeerManagerSendCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerSendCall) Return(arg0 *pb.Message, arg1 error) *PeerManagerSendCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerSendCall) Do(f func(string, *pb.Message) (*pb.Message, error)) *PeerManagerSendCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerSendCall) DoAndReturn(f func(string, *pb.Message) (*pb.Message, error)) *PeerManagerSendCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendWithStream mocks base method.
func (m *MockPeerManager) SendWithStream(arg0 network.Stream, arg1 *pb.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendWithStream", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendWithStream indicates an expected call of SendWithStream.
func (mr *MockPeerManagerMockRecorder) SendWithStream(arg0, arg1 any) *PeerManagerSendWithStreamCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendWithStream", reflect.TypeOf((*MockPeerManager)(nil).SendWithStream), arg0, arg1)
	return &PeerManagerSendWithStreamCall{Call: call}
}

// PeerManagerSendWithStreamCall wrap *gomock.Call
type PeerManagerSendWithStreamCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerSendWithStreamCall) Return(arg0 error) *PeerManagerSendWithStreamCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerSendWithStreamCall) Do(f func(network.Stream, *pb.Message) error) *PeerManagerSendWithStreamCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerSendWithStreamCall) DoAndReturn(f func(network.Stream, *pb.Message) error) *PeerManagerSendWithStreamCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockPeerManager) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockPeerManagerMockRecorder) Start() *PeerManagerStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockPeerManager)(nil).Start))
	return &PeerManagerStartCall{Call: call}
}

// PeerManagerStartCall wrap *gomock.Call
type PeerManagerStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerStartCall) Return(arg0 error) *PeerManagerStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerStartCall) Do(f func() error) *PeerManagerStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerStartCall) DoAndReturn(f func() error) *PeerManagerStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockPeerManager) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockPeerManagerMockRecorder) Stop() *PeerManagerStopCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockPeerManager)(nil).Stop))
	return &PeerManagerStopCall{Call: call}
}

// PeerManagerStopCall wrap *gomock.Call
type PeerManagerStopCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *PeerManagerStopCall) Return(arg0 error) *PeerManagerStopCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *PeerManagerStopCall) Do(f func() error) *PeerManagerStopCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *PeerManagerStopCall) DoAndReturn(f func() error) *PeerManagerStopCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
