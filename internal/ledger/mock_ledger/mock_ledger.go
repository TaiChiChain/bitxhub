// Code generated by MockGen. DO NOT EDIT.
// Source: ledger.go
//
// Generated by this command:
//
//	mockgen -destination mock_ledger/mock_ledger.go -package mock_ledger -source ledger.go -typed
//

// Package mock_ledger is a generated GoMock package.
package mock_ledger

import (
	big "math/big"
	reflect "reflect"

	types "github.com/axiomesh/axiom-kit/types"
	ledger "github.com/axiomesh/axiom-ledger/internal/ledger"
	common "github.com/ethereum/go-ethereum/common"
	types0 "github.com/ethereum/go-ethereum/core/types"
	params "github.com/ethereum/go-ethereum/params"
	gomock "go.uber.org/mock/gomock"
)

// MockChainLedger is a mock of ChainLedger interface.
type MockChainLedger struct {
	ctrl     *gomock.Controller
	recorder *MockChainLedgerMockRecorder
}

// MockChainLedgerMockRecorder is the mock recorder for MockChainLedger.
type MockChainLedgerMockRecorder struct {
	mock *MockChainLedger
}

// NewMockChainLedger creates a new mock instance.
func NewMockChainLedger(ctrl *gomock.Controller) *MockChainLedger {
	mock := &MockChainLedger{ctrl: ctrl}
	mock.recorder = &MockChainLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChainLedger) EXPECT() *MockChainLedgerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockChainLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockChainLedgerMockRecorder) Close() *ChainLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockChainLedger)(nil).Close))
	return &ChainLedgerCloseCall{Call: call}
}

// ChainLedgerCloseCall wrap *gomock.Call
type ChainLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerCloseCall) Return() *ChainLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerCloseCall) Do(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerCloseCall) DoAndReturn(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloseBlockfile mocks base method.
func (m *MockChainLedger) CloseBlockfile() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseBlockfile")
}

// CloseBlockfile indicates an expected call of CloseBlockfile.
func (mr *MockChainLedgerMockRecorder) CloseBlockfile() *ChainLedgerCloseBlockfileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseBlockfile", reflect.TypeOf((*MockChainLedger)(nil).CloseBlockfile))
	return &ChainLedgerCloseBlockfileCall{Call: call}
}

// ChainLedgerCloseBlockfileCall wrap *gomock.Call
type ChainLedgerCloseBlockfileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerCloseBlockfileCall) Return() *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerCloseBlockfileCall) Do(f func()) *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerCloseBlockfileCall) DoAndReturn(f func()) *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlock mocks base method.
func (m *MockChainLedger) GetBlock(height uint64) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlock", height)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockChainLedgerMockRecorder) GetBlock(height any) *ChainLedgerGetBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockChainLedger)(nil).GetBlock), height)
	return &ChainLedgerGetBlockCall{Call: call}
}

// ChainLedgerGetBlockCall wrap *gomock.Call
type ChainLedgerGetBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockCall) Do(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockCall) DoAndReturn(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockByHash mocks base method.
func (m *MockChainLedger) GetBlockByHash(hash *types.Hash) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockByHash", hash)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockByHash indicates an expected call of GetBlockByHash.
func (mr *MockChainLedgerMockRecorder) GetBlockByHash(hash any) *ChainLedgerGetBlockByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockByHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockByHash), hash)
	return &ChainLedgerGetBlockByHashCall{Call: call}
}

// ChainLedgerGetBlockByHashCall wrap *gomock.Call
type ChainLedgerGetBlockByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockByHashCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockByHashCall) Do(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockByHashCall) DoAndReturn(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockHash mocks base method.
func (m *MockChainLedger) GetBlockHash(height uint64) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockHash", height)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetBlockHash indicates an expected call of GetBlockHash.
func (mr *MockChainLedgerMockRecorder) GetBlockHash(height any) *ChainLedgerGetBlockHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockHash), height)
	return &ChainLedgerGetBlockHashCall{Call: call}
}

// ChainLedgerGetBlockHashCall wrap *gomock.Call
type ChainLedgerGetBlockHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockHashCall) Return(arg0 *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockHashCall) Do(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockHashCall) DoAndReturn(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockSign mocks base method.
func (m *MockChainLedger) GetBlockSign(height uint64) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockSign", height)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockSign indicates an expected call of GetBlockSign.
func (mr *MockChainLedgerMockRecorder) GetBlockSign(height any) *ChainLedgerGetBlockSignCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockSign", reflect.TypeOf((*MockChainLedger)(nil).GetBlockSign), height)
	return &ChainLedgerGetBlockSignCall{Call: call}
}

// ChainLedgerGetBlockSignCall wrap *gomock.Call
type ChainLedgerGetBlockSignCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockSignCall) Return(arg0 []byte, arg1 error) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockSignCall) Do(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockSignCall) DoAndReturn(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainMeta mocks base method.
func (m *MockChainLedger) GetChainMeta() *types.ChainMeta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	return ret0
}

// GetChainMeta indicates an expected call of GetChainMeta.
func (mr *MockChainLedgerMockRecorder) GetChainMeta() *ChainLedgerGetChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainMeta", reflect.TypeOf((*MockChainLedger)(nil).GetChainMeta))
	return &ChainLedgerGetChainMetaCall{Call: call}
}

// ChainLedgerGetChainMetaCall wrap *gomock.Call
type ChainLedgerGetChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetChainMetaCall) Return(arg0 *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetChainMetaCall) Do(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetChainMetaCall) DoAndReturn(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReceipt mocks base method.
func (m *MockChainLedger) GetReceipt(hash *types.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReceipt", hash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReceipt indicates an expected call of GetReceipt.
func (mr *MockChainLedgerMockRecorder) GetReceipt(hash any) *ChainLedgerGetReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceipt", reflect.TypeOf((*MockChainLedger)(nil).GetReceipt), hash)
	return &ChainLedgerGetReceiptCall{Call: call}
}

// ChainLedgerGetReceiptCall wrap *gomock.Call
type ChainLedgerGetReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetReceiptCall) Return(arg0 *types.Receipt, arg1 error) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetReceiptCall) Do(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetReceiptCall) DoAndReturn(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *MockChainLedger) GetTransaction(hash *types.Hash) (*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", hash)
	ret0, _ := ret[0].(*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *MockChainLedgerMockRecorder) GetTransaction(hash any) *ChainLedgerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockChainLedger)(nil).GetTransaction), hash)
	return &ChainLedgerGetTransactionCall{Call: call}
}

// ChainLedgerGetTransactionCall wrap *gomock.Call
type ChainLedgerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCall) Return(arg0 *types.Transaction, arg1 error) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCall) Do(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCall) DoAndReturn(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionCount mocks base method.
func (m *MockChainLedger) GetTransactionCount(height uint64) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionCount", height)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionCount indicates an expected call of GetTransactionCount.
func (mr *MockChainLedgerMockRecorder) GetTransactionCount(height any) *ChainLedgerGetTransactionCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionCount", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionCount), height)
	return &ChainLedgerGetTransactionCountCall{Call: call}
}

// ChainLedgerGetTransactionCountCall wrap *gomock.Call
type ChainLedgerGetTransactionCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCountCall) Return(arg0 uint64, arg1 error) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCountCall) Do(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCountCall) DoAndReturn(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionMeta mocks base method.
func (m *MockChainLedger) GetTransactionMeta(hash *types.Hash) (*types.TransactionMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionMeta", hash)
	ret0, _ := ret[0].(*types.TransactionMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionMeta indicates an expected call of GetTransactionMeta.
func (mr *MockChainLedgerMockRecorder) GetTransactionMeta(hash any) *ChainLedgerGetTransactionMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionMeta", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionMeta), hash)
	return &ChainLedgerGetTransactionMetaCall{Call: call}
}

// ChainLedgerGetTransactionMetaCall wrap *gomock.Call
type ChainLedgerGetTransactionMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionMetaCall) Return(arg0 *types.TransactionMeta, arg1 error) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionMetaCall) Do(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionMetaCall) DoAndReturn(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoadChainMeta mocks base method.
func (m *MockChainLedger) LoadChainMeta() (*types.ChainMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadChainMeta indicates an expected call of LoadChainMeta.
func (mr *MockChainLedgerMockRecorder) LoadChainMeta() *ChainLedgerLoadChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadChainMeta", reflect.TypeOf((*MockChainLedger)(nil).LoadChainMeta))
	return &ChainLedgerLoadChainMetaCall{Call: call}
}

// ChainLedgerLoadChainMetaCall wrap *gomock.Call
type ChainLedgerLoadChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerLoadChainMetaCall) Return(arg0 *types.ChainMeta, arg1 error) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerLoadChainMetaCall) Do(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerLoadChainMetaCall) DoAndReturn(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PersistExecutionResult mocks base method.
func (m *MockChainLedger) PersistExecutionResult(block *types.Block, receipts []*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PersistExecutionResult", block, receipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// PersistExecutionResult indicates an expected call of PersistExecutionResult.
func (mr *MockChainLedgerMockRecorder) PersistExecutionResult(block, receipts any) *ChainLedgerPersistExecutionResultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistExecutionResult", reflect.TypeOf((*MockChainLedger)(nil).PersistExecutionResult), block, receipts)
	return &ChainLedgerPersistExecutionResultCall{Call: call}
}

// ChainLedgerPersistExecutionResultCall wrap *gomock.Call
type ChainLedgerPersistExecutionResultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerPersistExecutionResultCall) Return(arg0 error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerPersistExecutionResultCall) Do(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerPersistExecutionResultCall) DoAndReturn(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlockChain mocks base method.
func (m *MockChainLedger) RollbackBlockChain(height uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlockChain", height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBlockChain indicates an expected call of RollbackBlockChain.
func (mr *MockChainLedgerMockRecorder) RollbackBlockChain(height any) *ChainLedgerRollbackBlockChainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlockChain", reflect.TypeOf((*MockChainLedger)(nil).RollbackBlockChain), height)
	return &ChainLedgerRollbackBlockChainCall{Call: call}
}

// ChainLedgerRollbackBlockChainCall wrap *gomock.Call
type ChainLedgerRollbackBlockChainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerRollbackBlockChainCall) Return(arg0 error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerRollbackBlockChainCall) Do(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerRollbackBlockChainCall) DoAndReturn(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainMeta mocks base method.
func (m *MockChainLedger) UpdateChainMeta(arg0 *types.ChainMeta) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainMeta", arg0)
}

// UpdateChainMeta indicates an expected call of UpdateChainMeta.
func (mr *MockChainLedgerMockRecorder) UpdateChainMeta(arg0 any) *ChainLedgerUpdateChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainMeta", reflect.TypeOf((*MockChainLedger)(nil).UpdateChainMeta), arg0)
	return &ChainLedgerUpdateChainMetaCall{Call: call}
}

// ChainLedgerUpdateChainMetaCall wrap *gomock.Call
type ChainLedgerUpdateChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerUpdateChainMetaCall) Return() *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerUpdateChainMetaCall) Do(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerUpdateChainMetaCall) DoAndReturn(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateLedger is a mock of StateLedger interface.
type MockStateLedger struct {
	ctrl     *gomock.Controller
	recorder *MockStateLedgerMockRecorder
}

// MockStateLedgerMockRecorder is the mock recorder for MockStateLedger.
type MockStateLedgerMockRecorder struct {
	mock *MockStateLedger
}

// NewMockStateLedger creates a new mock instance.
func NewMockStateLedger(ctrl *gomock.Controller) *MockStateLedger {
	mock := &MockStateLedger{ctrl: ctrl}
	mock.recorder = &MockStateLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateLedger) EXPECT() *MockStateLedgerMockRecorder {
	return m.recorder
}

// AddAddressToEVMAccessList mocks base method.
func (m *MockStateLedger) AddAddressToEVMAccessList(addr common.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAddressToEVMAccessList", addr)
}

// AddAddressToEVMAccessList indicates an expected call of AddAddressToEVMAccessList.
func (mr *MockStateLedgerMockRecorder) AddAddressToEVMAccessList(addr any) *StateLedgerAddAddressToEVMAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAddressToEVMAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddAddressToEVMAccessList), addr)
	return &StateLedgerAddAddressToEVMAccessListCall{Call: call}
}

// StateLedgerAddAddressToEVMAccessListCall wrap *gomock.Call
type StateLedgerAddAddressToEVMAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddAddressToEVMAccessListCall) Return() *StateLedgerAddAddressToEVMAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddAddressToEVMAccessListCall) Do(f func(common.Address)) *StateLedgerAddAddressToEVMAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddAddressToEVMAccessListCall) DoAndReturn(f func(common.Address)) *StateLedgerAddAddressToEVMAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEVMBalance mocks base method.
func (m *MockStateLedger) AddEVMBalance(arg0 common.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddEVMBalance", arg0, arg1)
}

// AddEVMBalance indicates an expected call of AddEVMBalance.
func (mr *MockStateLedgerMockRecorder) AddEVMBalance(arg0, arg1 any) *StateLedgerAddEVMBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEVMBalance", reflect.TypeOf((*MockStateLedger)(nil).AddEVMBalance), arg0, arg1)
	return &StateLedgerAddEVMBalanceCall{Call: call}
}

// StateLedgerAddEVMBalanceCall wrap *gomock.Call
type StateLedgerAddEVMBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddEVMBalanceCall) Return() *StateLedgerAddEVMBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddEVMBalanceCall) Do(f func(common.Address, *big.Int)) *StateLedgerAddEVMBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddEVMBalanceCall) DoAndReturn(f func(common.Address, *big.Int)) *StateLedgerAddEVMBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEVMLog mocks base method.
func (m *MockStateLedger) AddEVMLog(log *types0.Log) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddEVMLog", log)
}

// AddEVMLog indicates an expected call of AddEVMLog.
func (mr *MockStateLedgerMockRecorder) AddEVMLog(log any) *StateLedgerAddEVMLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEVMLog", reflect.TypeOf((*MockStateLedger)(nil).AddEVMLog), log)
	return &StateLedgerAddEVMLogCall{Call: call}
}

// StateLedgerAddEVMLogCall wrap *gomock.Call
type StateLedgerAddEVMLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddEVMLogCall) Return() *StateLedgerAddEVMLogCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddEVMLogCall) Do(f func(*types0.Log)) *StateLedgerAddEVMLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddEVMLogCall) DoAndReturn(f func(*types0.Log)) *StateLedgerAddEVMLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEVMPreimage mocks base method.
func (m *MockStateLedger) AddEVMPreimage(arg0 common.Hash, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddEVMPreimage", arg0, arg1)
}

// AddEVMPreimage indicates an expected call of AddEVMPreimage.
func (mr *MockStateLedgerMockRecorder) AddEVMPreimage(arg0, arg1 any) *StateLedgerAddEVMPreimageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEVMPreimage", reflect.TypeOf((*MockStateLedger)(nil).AddEVMPreimage), arg0, arg1)
	return &StateLedgerAddEVMPreimageCall{Call: call}
}

// StateLedgerAddEVMPreimageCall wrap *gomock.Call
type StateLedgerAddEVMPreimageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddEVMPreimageCall) Return() *StateLedgerAddEVMPreimageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddEVMPreimageCall) Do(f func(common.Hash, []byte)) *StateLedgerAddEVMPreimageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddEVMPreimageCall) DoAndReturn(f func(common.Hash, []byte)) *StateLedgerAddEVMPreimageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddEVMRefund mocks base method.
func (m *MockStateLedger) AddEVMRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddEVMRefund", arg0)
}

// AddEVMRefund indicates an expected call of AddEVMRefund.
func (mr *MockStateLedgerMockRecorder) AddEVMRefund(arg0 any) *StateLedgerAddEVMRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEVMRefund", reflect.TypeOf((*MockStateLedger)(nil).AddEVMRefund), arg0)
	return &StateLedgerAddEVMRefundCall{Call: call}
}

// StateLedgerAddEVMRefundCall wrap *gomock.Call
type StateLedgerAddEVMRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddEVMRefundCall) Return() *StateLedgerAddEVMRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddEVMRefundCall) Do(f func(uint64)) *StateLedgerAddEVMRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddEVMRefundCall) DoAndReturn(f func(uint64)) *StateLedgerAddEVMRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddLog mocks base method.
func (m *MockStateLedger) AddLog(log *types.EvmLog) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddLog", log)
}

// AddLog indicates an expected call of AddLog.
func (mr *MockStateLedgerMockRecorder) AddLog(log any) *StateLedgerAddLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLog", reflect.TypeOf((*MockStateLedger)(nil).AddLog), log)
	return &StateLedgerAddLogCall{Call: call}
}

// StateLedgerAddLogCall wrap *gomock.Call
type StateLedgerAddLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddLogCall) Return() *StateLedgerAddLogCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddLogCall) Do(f func(*types.EvmLog)) *StateLedgerAddLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddLogCall) DoAndReturn(f func(*types.EvmLog)) *StateLedgerAddLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSlotToEVMAccessList mocks base method.
func (m *MockStateLedger) AddSlotToEVMAccessList(addr common.Address, slot common.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSlotToEVMAccessList", addr, slot)
}

// AddSlotToEVMAccessList indicates an expected call of AddSlotToEVMAccessList.
func (mr *MockStateLedgerMockRecorder) AddSlotToEVMAccessList(addr, slot any) *StateLedgerAddSlotToEVMAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSlotToEVMAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddSlotToEVMAccessList), addr, slot)
	return &StateLedgerAddSlotToEVMAccessListCall{Call: call}
}

// StateLedgerAddSlotToEVMAccessListCall wrap *gomock.Call
type StateLedgerAddSlotToEVMAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddSlotToEVMAccessListCall) Return() *StateLedgerAddSlotToEVMAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddSlotToEVMAccessListCall) Do(f func(common.Address, common.Hash)) *StateLedgerAddSlotToEVMAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddSlotToEVMAccessListCall) DoAndReturn(f func(common.Address, common.Hash)) *StateLedgerAddSlotToEVMAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddressInEVMAccessList mocks base method.
func (m *MockStateLedger) AddressInEVMAccessList(addr common.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddressInEVMAccessList", addr)
	ret0, _ := ret[0].(bool)
	return ret0
}

// AddressInEVMAccessList indicates an expected call of AddressInEVMAccessList.
func (mr *MockStateLedgerMockRecorder) AddressInEVMAccessList(addr any) *StateLedgerAddressInEVMAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddressInEVMAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddressInEVMAccessList), addr)
	return &StateLedgerAddressInEVMAccessListCall{Call: call}
}

// StateLedgerAddressInEVMAccessListCall wrap *gomock.Call
type StateLedgerAddressInEVMAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddressInEVMAccessListCall) Return(arg0 bool) *StateLedgerAddressInEVMAccessListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddressInEVMAccessListCall) Do(f func(common.Address) bool) *StateLedgerAddressInEVMAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddressInEVMAccessListCall) DoAndReturn(f func(common.Address) bool) *StateLedgerAddressInEVMAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Clear mocks base method.
func (m *MockStateLedger) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateLedgerMockRecorder) Clear() *StateLedgerClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateLedger)(nil).Clear))
	return &StateLedgerClearCall{Call: call}
}

// StateLedgerClearCall wrap *gomock.Call
type StateLedgerClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerClearCall) Return() *StateLedgerClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerClearCall) Do(f func()) *StateLedgerClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerClearCall) DoAndReturn(f func()) *StateLedgerClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearChangerAndRefund mocks base method.
func (m *MockStateLedger) ClearChangerAndRefund() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ClearChangerAndRefund")
}

// ClearChangerAndRefund indicates an expected call of ClearChangerAndRefund.
func (mr *MockStateLedgerMockRecorder) ClearChangerAndRefund() *StateLedgerClearChangerAndRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearChangerAndRefund", reflect.TypeOf((*MockStateLedger)(nil).ClearChangerAndRefund))
	return &StateLedgerClearChangerAndRefundCall{Call: call}
}

// StateLedgerClearChangerAndRefundCall wrap *gomock.Call
type StateLedgerClearChangerAndRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerClearChangerAndRefundCall) Return() *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerClearChangerAndRefundCall) Do(f func()) *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerClearChangerAndRefundCall) DoAndReturn(f func()) *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockStateLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockStateLedgerMockRecorder) Close() *StateLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStateLedger)(nil).Close))
	return &StateLedgerCloseCall{Call: call}
}

// StateLedgerCloseCall wrap *gomock.Call
type StateLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerCloseCall) Return() *StateLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerCloseCall) Do(f func()) *StateLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerCloseCall) DoAndReturn(f func()) *StateLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateLedger) Commit(height uint64, accounts map[string]ledger.IAccount, stateRoot *types.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", height, accounts, stateRoot)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockStateLedgerMockRecorder) Commit(height, accounts, stateRoot any) *StateLedgerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateLedger)(nil).Commit), height, accounts, stateRoot)
	return &StateLedgerCommitCall{Call: call}
}

// StateLedgerCommitCall wrap *gomock.Call
type StateLedgerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerCommitCall) Return(arg0 error) *StateLedgerCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerCommitCall) Do(f func(uint64, map[string]ledger.IAccount, *types.Hash) error) *StateLedgerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerCommitCall) DoAndReturn(f func(uint64, map[string]ledger.IAccount, *types.Hash) error) *StateLedgerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateEVMAccount mocks base method.
func (m *MockStateLedger) CreateEVMAccount(arg0 common.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CreateEVMAccount", arg0)
}

// CreateEVMAccount indicates an expected call of CreateEVMAccount.
func (mr *MockStateLedgerMockRecorder) CreateEVMAccount(arg0 any) *StateLedgerCreateEVMAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEVMAccount", reflect.TypeOf((*MockStateLedger)(nil).CreateEVMAccount), arg0)
	return &StateLedgerCreateEVMAccountCall{Call: call}
}

// StateLedgerCreateEVMAccountCall wrap *gomock.Call
type StateLedgerCreateEVMAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerCreateEVMAccountCall) Return() *StateLedgerCreateEVMAccountCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerCreateEVMAccountCall) Do(f func(common.Address)) *StateLedgerCreateEVMAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerCreateEVMAccountCall) DoAndReturn(f func(common.Address)) *StateLedgerCreateEVMAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// EmptyEVM mocks base method.
func (m *MockStateLedger) EmptyEVM(arg0 common.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EmptyEVM", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// EmptyEVM indicates an expected call of EmptyEVM.
func (mr *MockStateLedgerMockRecorder) EmptyEVM(arg0 any) *StateLedgerEmptyEVMCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EmptyEVM", reflect.TypeOf((*MockStateLedger)(nil).EmptyEVM), arg0)
	return &StateLedgerEmptyEVMCall{Call: call}
}

// StateLedgerEmptyEVMCall wrap *gomock.Call
type StateLedgerEmptyEVMCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerEmptyEVMCall) Return(arg0 bool) *StateLedgerEmptyEVMCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerEmptyEVMCall) Do(f func(common.Address) bool) *StateLedgerEmptyEVMCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerEmptyEVMCall) DoAndReturn(f func(common.Address) bool) *StateLedgerEmptyEVMCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExistEVM mocks base method.
func (m *MockStateLedger) ExistEVM(arg0 common.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistEVM", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// ExistEVM indicates an expected call of ExistEVM.
func (mr *MockStateLedgerMockRecorder) ExistEVM(arg0 any) *StateLedgerExistEVMCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistEVM", reflect.TypeOf((*MockStateLedger)(nil).ExistEVM), arg0)
	return &StateLedgerExistEVMCall{Call: call}
}

// StateLedgerExistEVMCall wrap *gomock.Call
type StateLedgerExistEVMCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerExistEVMCall) Return(arg0 bool) *StateLedgerExistEVMCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerExistEVMCall) Do(f func(common.Address) bool) *StateLedgerExistEVMCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerExistEVMCall) DoAndReturn(f func(common.Address) bool) *StateLedgerExistEVMCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockStateLedger) Finalise() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Finalise")
}

// Finalise indicates an expected call of Finalise.
func (mr *MockStateLedgerMockRecorder) Finalise() *StateLedgerFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockStateLedger)(nil).Finalise))
	return &StateLedgerFinaliseCall{Call: call}
}

// StateLedgerFinaliseCall wrap *gomock.Call
type StateLedgerFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerFinaliseCall) Return() *StateLedgerFinaliseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerFinaliseCall) Do(f func()) *StateLedgerFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerFinaliseCall) DoAndReturn(f func()) *StateLedgerFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushDirtyData mocks base method.
func (m *MockStateLedger) FlushDirtyData() (map[string]ledger.IAccount, *types.Hash) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushDirtyData")
	ret0, _ := ret[0].(map[string]ledger.IAccount)
	ret1, _ := ret[1].(*types.Hash)
	return ret0, ret1
}

// FlushDirtyData indicates an expected call of FlushDirtyData.
func (mr *MockStateLedgerMockRecorder) FlushDirtyData() *StateLedgerFlushDirtyDataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushDirtyData", reflect.TypeOf((*MockStateLedger)(nil).FlushDirtyData))
	return &StateLedgerFlushDirtyDataCall{Call: call}
}

// StateLedgerFlushDirtyDataCall wrap *gomock.Call
type StateLedgerFlushDirtyDataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerFlushDirtyDataCall) Return(arg0 map[string]ledger.IAccount, arg1 *types.Hash) *StateLedgerFlushDirtyDataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerFlushDirtyDataCall) Do(f func() (map[string]ledger.IAccount, *types.Hash)) *StateLedgerFlushDirtyDataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerFlushDirtyDataCall) DoAndReturn(f func() (map[string]ledger.IAccount, *types.Hash)) *StateLedgerFlushDirtyDataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateLedger) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateLedgerMockRecorder) GetAccount(arg0 any) *StateLedgerGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateLedger)(nil).GetAccount), arg0)
	return &StateLedgerGetAccountCall{Call: call}
}

// StateLedgerGetAccountCall wrap *gomock.Call
type StateLedgerGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetAccountCall) Return(arg0 ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateLedger) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateLedgerMockRecorder) GetBalance(arg0 any) *StateLedgerGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateLedger)(nil).GetBalance), arg0)
	return &StateLedgerGetBalanceCall{Call: call}
}

// StateLedgerGetBalanceCall wrap *gomock.Call
type StateLedgerGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetBalanceCall) Return(arg0 *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetBalanceCall) Do(f func(*types.Address) *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateLedger) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateLedgerMockRecorder) GetCode(arg0 any) *StateLedgerGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateLedger)(nil).GetCode), arg0)
	return &StateLedgerGetCodeCall{Call: call}
}

// StateLedgerGetCodeCall wrap *gomock.Call
type StateLedgerGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetCodeCall) Return(arg0 []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetCodeCall) Do(f func(*types.Address) []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMBalance mocks base method.
func (m *MockStateLedger) GetEVMBalance(arg0 common.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetEVMBalance indicates an expected call of GetEVMBalance.
func (mr *MockStateLedgerMockRecorder) GetEVMBalance(arg0 any) *StateLedgerGetEVMBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMBalance", reflect.TypeOf((*MockStateLedger)(nil).GetEVMBalance), arg0)
	return &StateLedgerGetEVMBalanceCall{Call: call}
}

// StateLedgerGetEVMBalanceCall wrap *gomock.Call
type StateLedgerGetEVMBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMBalanceCall) Return(arg0 *big.Int) *StateLedgerGetEVMBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMBalanceCall) Do(f func(common.Address) *big.Int) *StateLedgerGetEVMBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMBalanceCall) DoAndReturn(f func(common.Address) *big.Int) *StateLedgerGetEVMBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMCode mocks base method.
func (m *MockStateLedger) GetEVMCode(arg0 common.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetEVMCode indicates an expected call of GetEVMCode.
func (mr *MockStateLedgerMockRecorder) GetEVMCode(arg0 any) *StateLedgerGetEVMCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMCode", reflect.TypeOf((*MockStateLedger)(nil).GetEVMCode), arg0)
	return &StateLedgerGetEVMCodeCall{Call: call}
}

// StateLedgerGetEVMCodeCall wrap *gomock.Call
type StateLedgerGetEVMCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMCodeCall) Return(arg0 []byte) *StateLedgerGetEVMCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMCodeCall) Do(f func(common.Address) []byte) *StateLedgerGetEVMCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMCodeCall) DoAndReturn(f func(common.Address) []byte) *StateLedgerGetEVMCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMCodeHash mocks base method.
func (m *MockStateLedger) GetEVMCodeHash(arg0 common.Address) common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMCodeHash", arg0)
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetEVMCodeHash indicates an expected call of GetEVMCodeHash.
func (mr *MockStateLedgerMockRecorder) GetEVMCodeHash(arg0 any) *StateLedgerGetEVMCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMCodeHash", reflect.TypeOf((*MockStateLedger)(nil).GetEVMCodeHash), arg0)
	return &StateLedgerGetEVMCodeHashCall{Call: call}
}

// StateLedgerGetEVMCodeHashCall wrap *gomock.Call
type StateLedgerGetEVMCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMCodeHashCall) Return(arg0 common.Hash) *StateLedgerGetEVMCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMCodeHashCall) Do(f func(common.Address) common.Hash) *StateLedgerGetEVMCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMCodeHashCall) DoAndReturn(f func(common.Address) common.Hash) *StateLedgerGetEVMCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMCodeSize mocks base method.
func (m *MockStateLedger) GetEVMCodeSize(arg0 common.Address) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMCodeSize", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetEVMCodeSize indicates an expected call of GetEVMCodeSize.
func (mr *MockStateLedgerMockRecorder) GetEVMCodeSize(arg0 any) *StateLedgerGetEVMCodeSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMCodeSize", reflect.TypeOf((*MockStateLedger)(nil).GetEVMCodeSize), arg0)
	return &StateLedgerGetEVMCodeSizeCall{Call: call}
}

// StateLedgerGetEVMCodeSizeCall wrap *gomock.Call
type StateLedgerGetEVMCodeSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMCodeSizeCall) Return(arg0 int) *StateLedgerGetEVMCodeSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMCodeSizeCall) Do(f func(common.Address) int) *StateLedgerGetEVMCodeSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMCodeSizeCall) DoAndReturn(f func(common.Address) int) *StateLedgerGetEVMCodeSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMCommittedState mocks base method.
func (m *MockStateLedger) GetEVMCommittedState(arg0 common.Address, arg1 common.Hash) common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMCommittedState", arg0, arg1)
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetEVMCommittedState indicates an expected call of GetEVMCommittedState.
func (mr *MockStateLedgerMockRecorder) GetEVMCommittedState(arg0, arg1 any) *StateLedgerGetEVMCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMCommittedState", reflect.TypeOf((*MockStateLedger)(nil).GetEVMCommittedState), arg0, arg1)
	return &StateLedgerGetEVMCommittedStateCall{Call: call}
}

// StateLedgerGetEVMCommittedStateCall wrap *gomock.Call
type StateLedgerGetEVMCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMCommittedStateCall) Return(arg0 common.Hash) *StateLedgerGetEVMCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMCommittedStateCall) Do(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMCommittedStateCall) DoAndReturn(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMNonce mocks base method.
func (m *MockStateLedger) GetEVMNonce(arg0 common.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetEVMNonce indicates an expected call of GetEVMNonce.
func (mr *MockStateLedgerMockRecorder) GetEVMNonce(arg0 any) *StateLedgerGetEVMNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMNonce", reflect.TypeOf((*MockStateLedger)(nil).GetEVMNonce), arg0)
	return &StateLedgerGetEVMNonceCall{Call: call}
}

// StateLedgerGetEVMNonceCall wrap *gomock.Call
type StateLedgerGetEVMNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMNonceCall) Return(arg0 uint64) *StateLedgerGetEVMNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMNonceCall) Do(f func(common.Address) uint64) *StateLedgerGetEVMNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMNonceCall) DoAndReturn(f func(common.Address) uint64) *StateLedgerGetEVMNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMRefund mocks base method.
func (m *MockStateLedger) GetEVMRefund() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMRefund")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetEVMRefund indicates an expected call of GetEVMRefund.
func (mr *MockStateLedgerMockRecorder) GetEVMRefund() *StateLedgerGetEVMRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMRefund", reflect.TypeOf((*MockStateLedger)(nil).GetEVMRefund))
	return &StateLedgerGetEVMRefundCall{Call: call}
}

// StateLedgerGetEVMRefundCall wrap *gomock.Call
type StateLedgerGetEVMRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMRefundCall) Return(arg0 uint64) *StateLedgerGetEVMRefundCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMRefundCall) Do(f func() uint64) *StateLedgerGetEVMRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMRefundCall) DoAndReturn(f func() uint64) *StateLedgerGetEVMRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMState mocks base method.
func (m *MockStateLedger) GetEVMState(arg0 common.Address, arg1 common.Hash) common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMState", arg0, arg1)
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetEVMState indicates an expected call of GetEVMState.
func (mr *MockStateLedgerMockRecorder) GetEVMState(arg0, arg1 any) *StateLedgerGetEVMStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMState", reflect.TypeOf((*MockStateLedger)(nil).GetEVMState), arg0, arg1)
	return &StateLedgerGetEVMStateCall{Call: call}
}

// StateLedgerGetEVMStateCall wrap *gomock.Call
type StateLedgerGetEVMStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMStateCall) Return(arg0 common.Hash) *StateLedgerGetEVMStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMStateCall) Do(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMStateCall) DoAndReturn(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetEVMTransientState mocks base method.
func (m *MockStateLedger) GetEVMTransientState(addr common.Address, key common.Hash) common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEVMTransientState", addr, key)
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetEVMTransientState indicates an expected call of GetEVMTransientState.
func (mr *MockStateLedgerMockRecorder) GetEVMTransientState(addr, key any) *StateLedgerGetEVMTransientStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEVMTransientState", reflect.TypeOf((*MockStateLedger)(nil).GetEVMTransientState), addr, key)
	return &StateLedgerGetEVMTransientStateCall{Call: call}
}

// StateLedgerGetEVMTransientStateCall wrap *gomock.Call
type StateLedgerGetEVMTransientStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetEVMTransientStateCall) Return(arg0 common.Hash) *StateLedgerGetEVMTransientStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetEVMTransientStateCall) Do(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMTransientStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetEVMTransientStateCall) DoAndReturn(f func(common.Address, common.Hash) common.Hash) *StateLedgerGetEVMTransientStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLogs mocks base method.
func (m *MockStateLedger) GetLogs(arg0 types.Hash, arg1 uint64, arg2 *types.Hash) []*types.EvmLog {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*types.EvmLog)
	return ret0
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockStateLedgerMockRecorder) GetLogs(arg0, arg1, arg2 any) *StateLedgerGetLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockStateLedger)(nil).GetLogs), arg0, arg1, arg2)
	return &StateLedgerGetLogsCall{Call: call}
}

// StateLedgerGetLogsCall wrap *gomock.Call
type StateLedgerGetLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetLogsCall) Return(arg0 []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetLogsCall) Do(f func(types.Hash, uint64, *types.Hash) []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetLogsCall) DoAndReturn(f func(types.Hash, uint64, *types.Hash) []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateLedger) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateLedgerMockRecorder) GetNonce(arg0 any) *StateLedgerGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateLedger)(nil).GetNonce), arg0)
	return &StateLedgerGetNonceCall{Call: call}
}

// StateLedgerGetNonceCall wrap *gomock.Call
type StateLedgerGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetNonceCall) Return(arg0 uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetNonceCall) Do(f func(*types.Address) uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateLedger) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateLedgerMockRecorder) GetOrCreateAccount(arg0 any) *StateLedgerGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateLedger)(nil).GetOrCreateAccount), arg0)
	return &StateLedgerGetOrCreateAccountCall{Call: call}
}

// StateLedgerGetOrCreateAccountCall wrap *gomock.Call
type StateLedgerGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateLedger) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateLedgerMockRecorder) GetState(arg0, arg1 any) *StateLedgerGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateLedger)(nil).GetState), arg0, arg1)
	return &StateLedgerGetStateCall{Call: call}
}

// StateLedgerGetStateCall wrap *gomock.Call
type StateLedgerGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetStateCall) Return(arg0 bool, arg1 []byte) *StateLedgerGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *StateLedgerGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *StateLedgerGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasSuicideEVM mocks base method.
func (m *MockStateLedger) HasSuicideEVM(arg0 common.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSuicideEVM", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSuicideEVM indicates an expected call of HasSuicideEVM.
func (mr *MockStateLedgerMockRecorder) HasSuicideEVM(arg0 any) *StateLedgerHasSuicideEVMCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSuicideEVM", reflect.TypeOf((*MockStateLedger)(nil).HasSuicideEVM), arg0)
	return &StateLedgerHasSuicideEVMCall{Call: call}
}

// StateLedgerHasSuicideEVMCall wrap *gomock.Call
type StateLedgerHasSuicideEVMCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerHasSuicideEVMCall) Return(arg0 bool) *StateLedgerHasSuicideEVMCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerHasSuicideEVMCall) Do(f func(common.Address) bool) *StateLedgerHasSuicideEVMCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerHasSuicideEVMCall) DoAndReturn(f func(common.Address) bool) *StateLedgerHasSuicideEVMCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewView mocks base method.
func (m *MockStateLedger) NewView() ledger.StateLedger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewView")
	ret0, _ := ret[0].(ledger.StateLedger)
	return ret0
}

// NewView indicates an expected call of NewView.
func (mr *MockStateLedgerMockRecorder) NewView() *StateLedgerNewViewCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewView", reflect.TypeOf((*MockStateLedger)(nil).NewView))
	return &StateLedgerNewViewCall{Call: call}
}

// StateLedgerNewViewCall wrap *gomock.Call
type StateLedgerNewViewCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerNewViewCall) Return(arg0 ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerNewViewCall) Do(f func() ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerNewViewCall) DoAndReturn(f func() ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareBlock mocks base method.
func (m *MockStateLedger) PrepareBlock(arg0 *types.Hash, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PrepareBlock", arg0, arg1)
}

// PrepareBlock indicates an expected call of PrepareBlock.
func (mr *MockStateLedgerMockRecorder) PrepareBlock(arg0, arg1 any) *StateLedgerPrepareBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareBlock", reflect.TypeOf((*MockStateLedger)(nil).PrepareBlock), arg0, arg1)
	return &StateLedgerPrepareBlockCall{Call: call}
}

// StateLedgerPrepareBlockCall wrap *gomock.Call
type StateLedgerPrepareBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerPrepareBlockCall) Return() *StateLedgerPrepareBlockCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerPrepareBlockCall) Do(f func(*types.Hash, uint64)) *StateLedgerPrepareBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerPrepareBlockCall) DoAndReturn(f func(*types.Hash, uint64)) *StateLedgerPrepareBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareEVM mocks base method.
func (m *MockStateLedger) PrepareEVM(rules params.Rules, sender, coinbase common.Address, dest *common.Address, precompiles []common.Address, txAccesses types0.AccessList) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PrepareEVM", rules, sender, coinbase, dest, precompiles, txAccesses)
}

// PrepareEVM indicates an expected call of PrepareEVM.
func (mr *MockStateLedgerMockRecorder) PrepareEVM(rules, sender, coinbase, dest, precompiles, txAccesses any) *StateLedgerPrepareEVMCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareEVM", reflect.TypeOf((*MockStateLedger)(nil).PrepareEVM), rules, sender, coinbase, dest, precompiles, txAccesses)
	return &StateLedgerPrepareEVMCall{Call: call}
}

// StateLedgerPrepareEVMCall wrap *gomock.Call
type StateLedgerPrepareEVMCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerPrepareEVMCall) Return() *StateLedgerPrepareEVMCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerPrepareEVMCall) Do(f func(params.Rules, common.Address, common.Address, *common.Address, []common.Address, types0.AccessList)) *StateLedgerPrepareEVMCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerPrepareEVMCall) DoAndReturn(f func(params.Rules, common.Address, common.Address, *common.Address, []common.Address, types0.AccessList)) *StateLedgerPrepareEVMCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryByPrefix mocks base method.
func (m *MockStateLedger) QueryByPrefix(address *types.Address, prefix string) (bool, [][]byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryByPrefix", address, prefix)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([][]byte)
	return ret0, ret1
}

// QueryByPrefix indicates an expected call of QueryByPrefix.
func (mr *MockStateLedgerMockRecorder) QueryByPrefix(address, prefix any) *StateLedgerQueryByPrefixCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryByPrefix", reflect.TypeOf((*MockStateLedger)(nil).QueryByPrefix), address, prefix)
	return &StateLedgerQueryByPrefixCall{Call: call}
}

// StateLedgerQueryByPrefixCall wrap *gomock.Call
type StateLedgerQueryByPrefixCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerQueryByPrefixCall) Return(arg0 bool, arg1 [][]byte) *StateLedgerQueryByPrefixCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerQueryByPrefixCall) Do(f func(*types.Address, string) (bool, [][]byte)) *StateLedgerQueryByPrefixCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerQueryByPrefixCall) DoAndReturn(f func(*types.Address, string) (bool, [][]byte)) *StateLedgerQueryByPrefixCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertToSnapshot mocks base method.
func (m *MockStateLedger) RevertToSnapshot(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RevertToSnapshot", arg0)
}

// RevertToSnapshot indicates an expected call of RevertToSnapshot.
func (mr *MockStateLedgerMockRecorder) RevertToSnapshot(arg0 any) *StateLedgerRevertToSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertToSnapshot", reflect.TypeOf((*MockStateLedger)(nil).RevertToSnapshot), arg0)
	return &StateLedgerRevertToSnapshotCall{Call: call}
}

// StateLedgerRevertToSnapshotCall wrap *gomock.Call
type StateLedgerRevertToSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerRevertToSnapshotCall) Return() *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerRevertToSnapshotCall) Do(f func(int)) *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerRevertToSnapshotCall) DoAndReturn(f func(int)) *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackState mocks base method.
func (m *MockStateLedger) RollbackState(height uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackState", height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackState indicates an expected call of RollbackState.
func (mr *MockStateLedgerMockRecorder) RollbackState(height any) *StateLedgerRollbackStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackState", reflect.TypeOf((*MockStateLedger)(nil).RollbackState), height)
	return &StateLedgerRollbackStateCall{Call: call}
}

// StateLedgerRollbackStateCall wrap *gomock.Call
type StateLedgerRollbackStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerRollbackStateCall) Return(arg0 error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerRollbackStateCall) Do(f func(uint64) error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerRollbackStateCall) DoAndReturn(f func(uint64) error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateLedger) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateLedgerMockRecorder) SetBalance(arg0, arg1 any) *StateLedgerSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateLedger)(nil).SetBalance), arg0, arg1)
	return &StateLedgerSetBalanceCall{Call: call}
}

// StateLedgerSetBalanceCall wrap *gomock.Call
type StateLedgerSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetBalanceCall) Return() *StateLedgerSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetBalanceCall) Do(f func(*types.Address, *big.Int)) *StateLedgerSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateLedgerSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateLedger) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateLedgerMockRecorder) SetCode(arg0, arg1 any) *StateLedgerSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateLedger)(nil).SetCode), arg0, arg1)
	return &StateLedgerSetCodeCall{Call: call}
}

// StateLedgerSetCodeCall wrap *gomock.Call
type StateLedgerSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetCodeCall) Return() *StateLedgerSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetCodeCall) Do(f func(*types.Address, []byte)) *StateLedgerSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *StateLedgerSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEVMCode mocks base method.
func (m *MockStateLedger) SetEVMCode(arg0 common.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEVMCode", arg0, arg1)
}

// SetEVMCode indicates an expected call of SetEVMCode.
func (mr *MockStateLedgerMockRecorder) SetEVMCode(arg0, arg1 any) *StateLedgerSetEVMCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEVMCode", reflect.TypeOf((*MockStateLedger)(nil).SetEVMCode), arg0, arg1)
	return &StateLedgerSetEVMCodeCall{Call: call}
}

// StateLedgerSetEVMCodeCall wrap *gomock.Call
type StateLedgerSetEVMCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetEVMCodeCall) Return() *StateLedgerSetEVMCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetEVMCodeCall) Do(f func(common.Address, []byte)) *StateLedgerSetEVMCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetEVMCodeCall) DoAndReturn(f func(common.Address, []byte)) *StateLedgerSetEVMCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEVMNonce mocks base method.
func (m *MockStateLedger) SetEVMNonce(arg0 common.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEVMNonce", arg0, arg1)
}

// SetEVMNonce indicates an expected call of SetEVMNonce.
func (mr *MockStateLedgerMockRecorder) SetEVMNonce(arg0, arg1 any) *StateLedgerSetEVMNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEVMNonce", reflect.TypeOf((*MockStateLedger)(nil).SetEVMNonce), arg0, arg1)
	return &StateLedgerSetEVMNonceCall{Call: call}
}

// StateLedgerSetEVMNonceCall wrap *gomock.Call
type StateLedgerSetEVMNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetEVMNonceCall) Return() *StateLedgerSetEVMNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetEVMNonceCall) Do(f func(common.Address, uint64)) *StateLedgerSetEVMNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetEVMNonceCall) DoAndReturn(f func(common.Address, uint64)) *StateLedgerSetEVMNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEVMState mocks base method.
func (m *MockStateLedger) SetEVMState(arg0 common.Address, arg1, arg2 common.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEVMState", arg0, arg1, arg2)
}

// SetEVMState indicates an expected call of SetEVMState.
func (mr *MockStateLedgerMockRecorder) SetEVMState(arg0, arg1, arg2 any) *StateLedgerSetEVMStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEVMState", reflect.TypeOf((*MockStateLedger)(nil).SetEVMState), arg0, arg1, arg2)
	return &StateLedgerSetEVMStateCall{Call: call}
}

// StateLedgerSetEVMStateCall wrap *gomock.Call
type StateLedgerSetEVMStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetEVMStateCall) Return() *StateLedgerSetEVMStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetEVMStateCall) Do(f func(common.Address, common.Hash, common.Hash)) *StateLedgerSetEVMStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetEVMStateCall) DoAndReturn(f func(common.Address, common.Hash, common.Hash)) *StateLedgerSetEVMStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEVMTransientState mocks base method.
func (m *MockStateLedger) SetEVMTransientState(addr common.Address, key, value common.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEVMTransientState", addr, key, value)
}

// SetEVMTransientState indicates an expected call of SetEVMTransientState.
func (mr *MockStateLedgerMockRecorder) SetEVMTransientState(addr, key, value any) *StateLedgerSetEVMTransientStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEVMTransientState", reflect.TypeOf((*MockStateLedger)(nil).SetEVMTransientState), addr, key, value)
	return &StateLedgerSetEVMTransientStateCall{Call: call}
}

// StateLedgerSetEVMTransientStateCall wrap *gomock.Call
type StateLedgerSetEVMTransientStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetEVMTransientStateCall) Return() *StateLedgerSetEVMTransientStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetEVMTransientStateCall) Do(f func(common.Address, common.Hash, common.Hash)) *StateLedgerSetEVMTransientStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetEVMTransientStateCall) DoAndReturn(f func(common.Address, common.Hash, common.Hash)) *StateLedgerSetEVMTransientStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateLedger) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateLedgerMockRecorder) SetNonce(arg0, arg1 any) *StateLedgerSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateLedger)(nil).SetNonce), arg0, arg1)
	return &StateLedgerSetNonceCall{Call: call}
}

// StateLedgerSetNonceCall wrap *gomock.Call
type StateLedgerSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetNonceCall) Return() *StateLedgerSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetNonceCall) Do(f func(*types.Address, uint64)) *StateLedgerSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *StateLedgerSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateLedger) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateLedgerMockRecorder) SetState(arg0, arg1, arg2 any) *StateLedgerSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateLedger)(nil).SetState), arg0, arg1, arg2)
	return &StateLedgerSetStateCall{Call: call}
}

// StateLedgerSetStateCall wrap *gomock.Call
type StateLedgerSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetStateCall) Return() *StateLedgerSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetStateCall) Do(f func(*types.Address, []byte, []byte)) *StateLedgerSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *StateLedgerSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateLedger) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateLedgerMockRecorder) SetTxContext(thash, txIndex any) *StateLedgerSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateLedger)(nil).SetTxContext), thash, txIndex)
	return &StateLedgerSetTxContextCall{Call: call}
}

// StateLedgerSetTxContextCall wrap *gomock.Call
type StateLedgerSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetTxContextCall) Return() *StateLedgerSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetTxContextCall) Do(f func(*types.Hash, int)) *StateLedgerSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *StateLedgerSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlotInEVMAceessList mocks base method.
func (m *MockStateLedger) SlotInEVMAceessList(addr common.Address, slot common.Hash) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlotInEVMAceessList", addr, slot)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// SlotInEVMAceessList indicates an expected call of SlotInEVMAceessList.
func (mr *MockStateLedgerMockRecorder) SlotInEVMAceessList(addr, slot any) *StateLedgerSlotInEVMAceessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlotInEVMAceessList", reflect.TypeOf((*MockStateLedger)(nil).SlotInEVMAceessList), addr, slot)
	return &StateLedgerSlotInEVMAceessListCall{Call: call}
}

// StateLedgerSlotInEVMAceessListCall wrap *gomock.Call
type StateLedgerSlotInEVMAceessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSlotInEVMAceessListCall) Return(addressOk, slotOk bool) *StateLedgerSlotInEVMAceessListCall {
	c.Call = c.Call.Return(addressOk, slotOk)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSlotInEVMAceessListCall) Do(f func(common.Address, common.Hash) (bool, bool)) *StateLedgerSlotInEVMAceessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSlotInEVMAceessListCall) DoAndReturn(f func(common.Address, common.Hash) (bool, bool)) *StateLedgerSlotInEVMAceessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockStateLedger) Snapshot() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(int)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockStateLedgerMockRecorder) Snapshot() *StateLedgerSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockStateLedger)(nil).Snapshot))
	return &StateLedgerSnapshotCall{Call: call}
}

// StateLedgerSnapshotCall wrap *gomock.Call
type StateLedgerSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSnapshotCall) Return(arg0 int) *StateLedgerSnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSnapshotCall) Do(f func() int) *StateLedgerSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSnapshotCall) DoAndReturn(f func() int) *StateLedgerSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubEVMBalance mocks base method.
func (m *MockStateLedger) SubEVMBalance(arg0 common.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubEVMBalance", arg0, arg1)
}

// SubEVMBalance indicates an expected call of SubEVMBalance.
func (mr *MockStateLedgerMockRecorder) SubEVMBalance(arg0, arg1 any) *StateLedgerSubEVMBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubEVMBalance", reflect.TypeOf((*MockStateLedger)(nil).SubEVMBalance), arg0, arg1)
	return &StateLedgerSubEVMBalanceCall{Call: call}
}

// StateLedgerSubEVMBalanceCall wrap *gomock.Call
type StateLedgerSubEVMBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSubEVMBalanceCall) Return() *StateLedgerSubEVMBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSubEVMBalanceCall) Do(f func(common.Address, *big.Int)) *StateLedgerSubEVMBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSubEVMBalanceCall) DoAndReturn(f func(common.Address, *big.Int)) *StateLedgerSubEVMBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubEVMRefund mocks base method.
func (m *MockStateLedger) SubEVMRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubEVMRefund", arg0)
}

// SubEVMRefund indicates an expected call of SubEVMRefund.
func (mr *MockStateLedgerMockRecorder) SubEVMRefund(arg0 any) *StateLedgerSubEVMRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubEVMRefund", reflect.TypeOf((*MockStateLedger)(nil).SubEVMRefund), arg0)
	return &StateLedgerSubEVMRefundCall{Call: call}
}

// StateLedgerSubEVMRefundCall wrap *gomock.Call
type StateLedgerSubEVMRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSubEVMRefundCall) Return() *StateLedgerSubEVMRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSubEVMRefundCall) Do(f func(uint64)) *StateLedgerSubEVMRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSubEVMRefundCall) DoAndReturn(f func(uint64)) *StateLedgerSubEVMRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SuicideEVM mocks base method.
func (m *MockStateLedger) SuicideEVM(arg0 common.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SuicideEVM", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// SuicideEVM indicates an expected call of SuicideEVM.
func (mr *MockStateLedgerMockRecorder) SuicideEVM(arg0 any) *StateLedgerSuicideEVMCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SuicideEVM", reflect.TypeOf((*MockStateLedger)(nil).SuicideEVM), arg0)
	return &StateLedgerSuicideEVMCall{Call: call}
}

// StateLedgerSuicideEVMCall wrap *gomock.Call
type StateLedgerSuicideEVMCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSuicideEVMCall) Return(arg0 bool) *StateLedgerSuicideEVMCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSuicideEVMCall) Do(f func(common.Address) bool) *StateLedgerSuicideEVMCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSuicideEVMCall) DoAndReturn(f func(common.Address) bool) *StateLedgerSuicideEVMCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Version mocks base method.
func (m *MockStateLedger) Version() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Version")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// Version indicates an expected call of Version.
func (mr *MockStateLedgerMockRecorder) Version() *StateLedgerVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockStateLedger)(nil).Version))
	return &StateLedgerVersionCall{Call: call}
}

// StateLedgerVersionCall wrap *gomock.Call
type StateLedgerVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerVersionCall) Return(arg0 uint64) *StateLedgerVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerVersionCall) Do(f func() uint64) *StateLedgerVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerVersionCall) DoAndReturn(f func() uint64) *StateLedgerVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateAccessor is a mock of StateAccessor interface.
type MockStateAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockStateAccessorMockRecorder
}

// MockStateAccessorMockRecorder is the mock recorder for MockStateAccessor.
type MockStateAccessorMockRecorder struct {
	mock *MockStateAccessor
}

// NewMockStateAccessor creates a new mock instance.
func NewMockStateAccessor(ctrl *gomock.Controller) *MockStateAccessor {
	mock := &MockStateAccessor{ctrl: ctrl}
	mock.recorder = &MockStateAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateAccessor) EXPECT() *MockStateAccessorMockRecorder {
	return m.recorder
}

// Clear mocks base method.
func (m *MockStateAccessor) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateAccessorMockRecorder) Clear() *StateAccessorClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateAccessor)(nil).Clear))
	return &StateAccessorClearCall{Call: call}
}

// StateAccessorClearCall wrap *gomock.Call
type StateAccessorClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorClearCall) Return() *StateAccessorClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorClearCall) Do(f func()) *StateAccessorClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorClearCall) DoAndReturn(f func()) *StateAccessorClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateAccessor) Commit(height uint64, accounts map[string]ledger.IAccount, stateRoot *types.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", height, accounts, stateRoot)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockStateAccessorMockRecorder) Commit(height, accounts, stateRoot any) *StateAccessorCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateAccessor)(nil).Commit), height, accounts, stateRoot)
	return &StateAccessorCommitCall{Call: call}
}

// StateAccessorCommitCall wrap *gomock.Call
type StateAccessorCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorCommitCall) Return(arg0 error) *StateAccessorCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorCommitCall) Do(f func(uint64, map[string]ledger.IAccount, *types.Hash) error) *StateAccessorCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorCommitCall) DoAndReturn(f func(uint64, map[string]ledger.IAccount, *types.Hash) error) *StateAccessorCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FlushDirtyData mocks base method.
func (m *MockStateAccessor) FlushDirtyData() (map[string]ledger.IAccount, *types.Hash) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FlushDirtyData")
	ret0, _ := ret[0].(map[string]ledger.IAccount)
	ret1, _ := ret[1].(*types.Hash)
	return ret0, ret1
}

// FlushDirtyData indicates an expected call of FlushDirtyData.
func (mr *MockStateAccessorMockRecorder) FlushDirtyData() *StateAccessorFlushDirtyDataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlushDirtyData", reflect.TypeOf((*MockStateAccessor)(nil).FlushDirtyData))
	return &StateAccessorFlushDirtyDataCall{Call: call}
}

// StateAccessorFlushDirtyDataCall wrap *gomock.Call
type StateAccessorFlushDirtyDataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorFlushDirtyDataCall) Return(arg0 map[string]ledger.IAccount, arg1 *types.Hash) *StateAccessorFlushDirtyDataCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorFlushDirtyDataCall) Do(f func() (map[string]ledger.IAccount, *types.Hash)) *StateAccessorFlushDirtyDataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorFlushDirtyDataCall) DoAndReturn(f func() (map[string]ledger.IAccount, *types.Hash)) *StateAccessorFlushDirtyDataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateAccessor) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateAccessorMockRecorder) GetAccount(arg0 any) *StateAccessorGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetAccount), arg0)
	return &StateAccessorGetAccountCall{Call: call}
}

// StateAccessorGetAccountCall wrap *gomock.Call
type StateAccessorGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetAccountCall) Return(arg0 ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateAccessor) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateAccessorMockRecorder) GetBalance(arg0 any) *StateAccessorGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateAccessor)(nil).GetBalance), arg0)
	return &StateAccessorGetBalanceCall{Call: call}
}

// StateAccessorGetBalanceCall wrap *gomock.Call
type StateAccessorGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetBalanceCall) Return(arg0 *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetBalanceCall) Do(f func(*types.Address) *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateAccessor) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateAccessorMockRecorder) GetCode(arg0 any) *StateAccessorGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateAccessor)(nil).GetCode), arg0)
	return &StateAccessorGetCodeCall{Call: call}
}

// StateAccessorGetCodeCall wrap *gomock.Call
type StateAccessorGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetCodeCall) Return(arg0 []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetCodeCall) Do(f func(*types.Address) []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateAccessor) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateAccessorMockRecorder) GetNonce(arg0 any) *StateAccessorGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateAccessor)(nil).GetNonce), arg0)
	return &StateAccessorGetNonceCall{Call: call}
}

// StateAccessorGetNonceCall wrap *gomock.Call
type StateAccessorGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetNonceCall) Return(arg0 uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetNonceCall) Do(f func(*types.Address) uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateAccessor) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateAccessorMockRecorder) GetOrCreateAccount(arg0 any) *StateAccessorGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetOrCreateAccount), arg0)
	return &StateAccessorGetOrCreateAccountCall{Call: call}
}

// StateAccessorGetOrCreateAccountCall wrap *gomock.Call
type StateAccessorGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateAccessor) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateAccessorMockRecorder) GetState(arg0, arg1 any) *StateAccessorGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateAccessor)(nil).GetState), arg0, arg1)
	return &StateAccessorGetStateCall{Call: call}
}

// StateAccessorGetStateCall wrap *gomock.Call
type StateAccessorGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetStateCall) Return(arg0 bool, arg1 []byte) *StateAccessorGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *StateAccessorGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *StateAccessorGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryByPrefix mocks base method.
func (m *MockStateAccessor) QueryByPrefix(address *types.Address, prefix string) (bool, [][]byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryByPrefix", address, prefix)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([][]byte)
	return ret0, ret1
}

// QueryByPrefix indicates an expected call of QueryByPrefix.
func (mr *MockStateAccessorMockRecorder) QueryByPrefix(address, prefix any) *StateAccessorQueryByPrefixCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryByPrefix", reflect.TypeOf((*MockStateAccessor)(nil).QueryByPrefix), address, prefix)
	return &StateAccessorQueryByPrefixCall{Call: call}
}

// StateAccessorQueryByPrefixCall wrap *gomock.Call
type StateAccessorQueryByPrefixCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorQueryByPrefixCall) Return(arg0 bool, arg1 [][]byte) *StateAccessorQueryByPrefixCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorQueryByPrefixCall) Do(f func(*types.Address, string) (bool, [][]byte)) *StateAccessorQueryByPrefixCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorQueryByPrefixCall) DoAndReturn(f func(*types.Address, string) (bool, [][]byte)) *StateAccessorQueryByPrefixCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateAccessor) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateAccessorMockRecorder) SetBalance(arg0, arg1 any) *StateAccessorSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateAccessor)(nil).SetBalance), arg0, arg1)
	return &StateAccessorSetBalanceCall{Call: call}
}

// StateAccessorSetBalanceCall wrap *gomock.Call
type StateAccessorSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetBalanceCall) Return() *StateAccessorSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetBalanceCall) Do(f func(*types.Address, *big.Int)) *StateAccessorSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateAccessorSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateAccessor) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateAccessorMockRecorder) SetCode(arg0, arg1 any) *StateAccessorSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateAccessor)(nil).SetCode), arg0, arg1)
	return &StateAccessorSetCodeCall{Call: call}
}

// StateAccessorSetCodeCall wrap *gomock.Call
type StateAccessorSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetCodeCall) Return() *StateAccessorSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetCodeCall) Do(f func(*types.Address, []byte)) *StateAccessorSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *StateAccessorSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateAccessor) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateAccessorMockRecorder) SetNonce(arg0, arg1 any) *StateAccessorSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateAccessor)(nil).SetNonce), arg0, arg1)
	return &StateAccessorSetNonceCall{Call: call}
}

// StateAccessorSetNonceCall wrap *gomock.Call
type StateAccessorSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetNonceCall) Return() *StateAccessorSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetNonceCall) Do(f func(*types.Address, uint64)) *StateAccessorSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *StateAccessorSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateAccessor) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateAccessorMockRecorder) SetState(arg0, arg1, arg2 any) *StateAccessorSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateAccessor)(nil).SetState), arg0, arg1, arg2)
	return &StateAccessorSetStateCall{Call: call}
}

// StateAccessorSetStateCall wrap *gomock.Call
type StateAccessorSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetStateCall) Return() *StateAccessorSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetStateCall) Do(f func(*types.Address, []byte, []byte)) *StateAccessorSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *StateAccessorSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateAccessor) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateAccessorMockRecorder) SetTxContext(thash, txIndex any) *StateAccessorSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateAccessor)(nil).SetTxContext), thash, txIndex)
	return &StateAccessorSetTxContextCall{Call: call}
}

// StateAccessorSetTxContextCall wrap *gomock.Call
type StateAccessorSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetTxContextCall) Return() *StateAccessorSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetTxContextCall) Do(f func(*types.Hash, int)) *StateAccessorSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *StateAccessorSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockIAccount is a mock of IAccount interface.
type MockIAccount struct {
	ctrl     *gomock.Controller
	recorder *MockIAccountMockRecorder
}

// MockIAccountMockRecorder is the mock recorder for MockIAccount.
type MockIAccountMockRecorder struct {
	mock *MockIAccount
}

// NewMockIAccount creates a new mock instance.
func NewMockIAccount(ctrl *gomock.Controller) *MockIAccount {
	mock := &MockIAccount{ctrl: ctrl}
	mock.recorder = &MockIAccountMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAccount) EXPECT() *MockIAccountMockRecorder {
	return m.recorder
}

// AddBalance mocks base method.
func (m *MockIAccount) AddBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", amount)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockIAccountMockRecorder) AddBalance(amount any) *IAccountAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockIAccount)(nil).AddBalance), amount)
	return &IAccountAddBalanceCall{Call: call}
}

// IAccountAddBalanceCall wrap *gomock.Call
type IAccountAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountAddBalanceCall) Return() *IAccountAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountAddBalanceCall) Do(f func(*big.Int)) *IAccountAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountAddBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Code mocks base method.
func (m *MockIAccount) Code() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Code")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Code indicates an expected call of Code.
func (mr *MockIAccountMockRecorder) Code() *IAccountCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockIAccount)(nil).Code))
	return &IAccountCodeCall{Call: call}
}

// IAccountCodeCall wrap *gomock.Call
type IAccountCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountCodeCall) Return(arg0 []byte) *IAccountCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountCodeCall) Do(f func() []byte) *IAccountCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountCodeCall) DoAndReturn(f func() []byte) *IAccountCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CodeHash mocks base method.
func (m *MockIAccount) CodeHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CodeHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// CodeHash indicates an expected call of CodeHash.
func (mr *MockIAccountMockRecorder) CodeHash() *IAccountCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CodeHash", reflect.TypeOf((*MockIAccount)(nil).CodeHash))
	return &IAccountCodeHashCall{Call: call}
}

// IAccountCodeHashCall wrap *gomock.Call
type IAccountCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountCodeHashCall) Return(arg0 []byte) *IAccountCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountCodeHashCall) Do(f func() []byte) *IAccountCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountCodeHashCall) DoAndReturn(f func() []byte) *IAccountCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockIAccount) Finalise() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Finalise")
}

// Finalise indicates an expected call of Finalise.
func (mr *MockIAccountMockRecorder) Finalise() *IAccountFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockIAccount)(nil).Finalise))
	return &IAccountFinaliseCall{Call: call}
}

// IAccountFinaliseCall wrap *gomock.Call
type IAccountFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountFinaliseCall) Return() *IAccountFinaliseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountFinaliseCall) Do(f func()) *IAccountFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountFinaliseCall) DoAndReturn(f func()) *IAccountFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAddress mocks base method.
func (m *MockIAccount) GetAddress() *types.Address {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddress")
	ret0, _ := ret[0].(*types.Address)
	return ret0
}

// GetAddress indicates an expected call of GetAddress.
func (mr *MockIAccountMockRecorder) GetAddress() *IAccountGetAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddress", reflect.TypeOf((*MockIAccount)(nil).GetAddress))
	return &IAccountGetAddressCall{Call: call}
}

// IAccountGetAddressCall wrap *gomock.Call
type IAccountGetAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetAddressCall) Return(arg0 *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetAddressCall) Do(f func() *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetAddressCall) DoAndReturn(f func() *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockIAccount) GetBalance() *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance")
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockIAccountMockRecorder) GetBalance() *IAccountGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockIAccount)(nil).GetBalance))
	return &IAccountGetBalanceCall{Call: call}
}

// IAccountGetBalanceCall wrap *gomock.Call
type IAccountGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetBalanceCall) Return(arg0 *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetBalanceCall) Do(f func() *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetBalanceCall) DoAndReturn(f func() *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockIAccount) GetCommittedState(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockIAccountMockRecorder) GetCommittedState(key any) *IAccountGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockIAccount)(nil).GetCommittedState), key)
	return &IAccountGetCommittedStateCall{Call: call}
}

// IAccountGetCommittedStateCall wrap *gomock.Call
type IAccountGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetCommittedStateCall) Return(arg0 []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetCommittedStateCall) Do(f func([]byte) []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetCommittedStateCall) DoAndReturn(f func([]byte) []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockIAccount) GetNonce() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockIAccountMockRecorder) GetNonce() *IAccountGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockIAccount)(nil).GetNonce))
	return &IAccountGetNonceCall{Call: call}
}

// IAccountGetNonceCall wrap *gomock.Call
type IAccountGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetNonceCall) Return(arg0 uint64) *IAccountGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetNonceCall) Do(f func() uint64) *IAccountGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetNonceCall) DoAndReturn(f func() uint64) *IAccountGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockIAccount) GetState(key []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockIAccountMockRecorder) GetState(key any) *IAccountGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockIAccount)(nil).GetState), key)
	return &IAccountGetStateCall{Call: call}
}

// IAccountGetStateCall wrap *gomock.Call
type IAccountGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetStateCall) Return(arg0 bool, arg1 []byte) *IAccountGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetStateCall) Do(f func([]byte) (bool, []byte)) *IAccountGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetStateCall) DoAndReturn(f func([]byte) (bool, []byte)) *IAccountGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsEmpty mocks base method.
func (m *MockIAccount) IsEmpty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockIAccountMockRecorder) IsEmpty() *IAccountIsEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockIAccount)(nil).IsEmpty))
	return &IAccountIsEmptyCall{Call: call}
}

// IAccountIsEmptyCall wrap *gomock.Call
type IAccountIsEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountIsEmptyCall) Return(arg0 bool) *IAccountIsEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountIsEmptyCall) Do(f func() bool) *IAccountIsEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountIsEmptyCall) DoAndReturn(f func() bool) *IAccountIsEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockIAccount) Query(prefix string) (bool, [][]byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", prefix)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([][]byte)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockIAccountMockRecorder) Query(prefix any) *IAccountQueryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIAccount)(nil).Query), prefix)
	return &IAccountQueryCall{Call: call}
}

// IAccountQueryCall wrap *gomock.Call
type IAccountQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountQueryCall) Return(arg0 bool, arg1 [][]byte) *IAccountQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountQueryCall) Do(f func(string) (bool, [][]byte)) *IAccountQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountQueryCall) DoAndReturn(f func(string) (bool, [][]byte)) *IAccountQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockIAccount) SetBalance(balance *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", balance)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockIAccountMockRecorder) SetBalance(balance any) *IAccountSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockIAccount)(nil).SetBalance), balance)
	return &IAccountSetBalanceCall{Call: call}
}

// IAccountSetBalanceCall wrap *gomock.Call
type IAccountSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetBalanceCall) Return() *IAccountSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetBalanceCall) Do(f func(*big.Int)) *IAccountSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCodeAndHash mocks base method.
func (m *MockIAccount) SetCodeAndHash(code []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCodeAndHash", code)
}

// SetCodeAndHash indicates an expected call of SetCodeAndHash.
func (mr *MockIAccountMockRecorder) SetCodeAndHash(code any) *IAccountSetCodeAndHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCodeAndHash", reflect.TypeOf((*MockIAccount)(nil).SetCodeAndHash), code)
	return &IAccountSetCodeAndHashCall{Call: call}
}

// IAccountSetCodeAndHashCall wrap *gomock.Call
type IAccountSetCodeAndHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetCodeAndHashCall) Return() *IAccountSetCodeAndHashCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetCodeAndHashCall) Do(f func([]byte)) *IAccountSetCodeAndHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetCodeAndHashCall) DoAndReturn(f func([]byte)) *IAccountSetCodeAndHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockIAccount) SetNonce(nonce uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", nonce)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockIAccountMockRecorder) SetNonce(nonce any) *IAccountSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockIAccount)(nil).SetNonce), nonce)
	return &IAccountSetNonceCall{Call: call}
}

// IAccountSetNonceCall wrap *gomock.Call
type IAccountSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetNonceCall) Return() *IAccountSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetNonceCall) Do(f func(uint64)) *IAccountSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetNonceCall) DoAndReturn(f func(uint64)) *IAccountSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockIAccount) SetState(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", key, value)
}

// SetState indicates an expected call of SetState.
func (mr *MockIAccountMockRecorder) SetState(key, value any) *IAccountSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockIAccount)(nil).SetState), key, value)
	return &IAccountSetStateCall{Call: call}
}

// IAccountSetStateCall wrap *gomock.Call
type IAccountSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetStateCall) Return() *IAccountSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetStateCall) Do(f func([]byte, []byte)) *IAccountSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetStateCall) DoAndReturn(f func([]byte, []byte)) *IAccountSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSuicided mocks base method.
func (m *MockIAccount) SetSuicided(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetSuicided", arg0)
}

// SetSuicided indicates an expected call of SetSuicided.
func (mr *MockIAccountMockRecorder) SetSuicided(arg0 any) *IAccountSetSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSuicided", reflect.TypeOf((*MockIAccount)(nil).SetSuicided), arg0)
	return &IAccountSetSuicidedCall{Call: call}
}

// IAccountSetSuicidedCall wrap *gomock.Call
type IAccountSetSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetSuicidedCall) Return() *IAccountSetSuicidedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetSuicidedCall) Do(f func(bool)) *IAccountSetSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetSuicidedCall) DoAndReturn(f func(bool)) *IAccountSetSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// String mocks base method.
func (m *MockIAccount) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockIAccountMockRecorder) String() *IAccountStringCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockIAccount)(nil).String))
	return &IAccountStringCall{Call: call}
}

// IAccountStringCall wrap *gomock.Call
type IAccountStringCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountStringCall) Return(arg0 string) *IAccountStringCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountStringCall) Do(f func() string) *IAccountStringCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountStringCall) DoAndReturn(f func() string) *IAccountStringCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockIAccount) SubBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", amount)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockIAccountMockRecorder) SubBalance(amount any) *IAccountSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockIAccount)(nil).SubBalance), amount)
	return &IAccountSubBalanceCall{Call: call}
}

// IAccountSubBalanceCall wrap *gomock.Call
type IAccountSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSubBalanceCall) Return() *IAccountSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSubBalanceCall) Do(f func(*big.Int)) *IAccountSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSubBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicided mocks base method.
func (m *MockIAccount) Suicided() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicided")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicided indicates an expected call of Suicided.
func (mr *MockIAccountMockRecorder) Suicided() *IAccountSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicided", reflect.TypeOf((*MockIAccount)(nil).Suicided))
	return &IAccountSuicidedCall{Call: call}
}

// IAccountSuicidedCall wrap *gomock.Call
type IAccountSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSuicidedCall) Return(arg0 bool) *IAccountSuicidedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSuicidedCall) Do(f func() bool) *IAccountSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSuicidedCall) DoAndReturn(f func() bool) *IAccountSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
