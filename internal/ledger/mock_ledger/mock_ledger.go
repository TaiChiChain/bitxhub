// Code generated by MockGen. DO NOT EDIT.
// Source: ledger.go
//
// Generated by this command:
//
//	mockgen -destination mock_ledger/mock_ledger.go -package mock_ledger -source ledger.go -typed
//

// Package mock_ledger is a generated GoMock package.
package mock_ledger

import (
	big "math/big"
	reflect "reflect"

	jmt "github.com/axiomesh/axiom-kit/jmt"
	kv "github.com/axiomesh/axiom-kit/storage/kv"
	types "github.com/axiomesh/axiom-kit/types"
	ledger "github.com/axiomesh/axiom-ledger/internal/ledger"
	common "github.com/ethereum/go-ethereum/common"
	gomock "go.uber.org/mock/gomock"
)

// MockChainLedger is a mock of ChainLedger interface.
type MockChainLedger struct {
	ctrl     *gomock.Controller
	recorder *MockChainLedgerMockRecorder
}

// MockChainLedgerMockRecorder is the mock recorder for MockChainLedger.
type MockChainLedgerMockRecorder struct {
	mock *MockChainLedger
}

// NewMockChainLedger creates a new mock instance.
func NewMockChainLedger(ctrl *gomock.Controller) *MockChainLedger {
	mock := &MockChainLedger{ctrl: ctrl}
	mock.recorder = &MockChainLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChainLedger) EXPECT() *MockChainLedgerMockRecorder {
	return m.recorder
}

// BatchPersistExecutionResult mocks base method.
func (m *MockChainLedger) BatchPersistExecutionResult(batchBlock []*types.Block, BatchReceipts [][]*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchPersistExecutionResult", batchBlock, BatchReceipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// BatchPersistExecutionResult indicates an expected call of BatchPersistExecutionResult.
func (mr *MockChainLedgerMockRecorder) BatchPersistExecutionResult(batchBlock, BatchReceipts any) *MockChainLedgerBatchPersistExecutionResultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchPersistExecutionResult", reflect.TypeOf((*MockChainLedger)(nil).BatchPersistExecutionResult), batchBlock, BatchReceipts)
	return &MockChainLedgerBatchPersistExecutionResultCall{Call: call}
}

// MockChainLedgerBatchPersistExecutionResultCall wrap *gomock.Call
type MockChainLedgerBatchPersistExecutionResultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerBatchPersistExecutionResultCall) Return(arg0 error) *MockChainLedgerBatchPersistExecutionResultCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerBatchPersistExecutionResultCall) Do(f func([]*types.Block, [][]*types.Receipt) error) *MockChainLedgerBatchPersistExecutionResultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerBatchPersistExecutionResultCall) DoAndReturn(f func([]*types.Block, [][]*types.Receipt) error) *MockChainLedgerBatchPersistExecutionResultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockChainLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockChainLedgerMockRecorder) Close() *MockChainLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockChainLedger)(nil).Close))
	return &MockChainLedgerCloseCall{Call: call}
}

// MockChainLedgerCloseCall wrap *gomock.Call
type MockChainLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerCloseCall) Return() *MockChainLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerCloseCall) Do(f func()) *MockChainLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerCloseCall) DoAndReturn(f func()) *MockChainLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlock mocks base method.
func (m *MockChainLedger) GetBlock(height uint64) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlock", height)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockChainLedgerMockRecorder) GetBlock(height any) *MockChainLedgerGetBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockChainLedger)(nil).GetBlock), height)
	return &MockChainLedgerGetBlockCall{Call: call}
}

// MockChainLedgerGetBlockCall wrap *gomock.Call
type MockChainLedgerGetBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockCall) Return(arg0 *types.Block, arg1 error) *MockChainLedgerGetBlockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockCall) Do(f func(uint64) (*types.Block, error)) *MockChainLedgerGetBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockCall) DoAndReturn(f func(uint64) (*types.Block, error)) *MockChainLedgerGetBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockExtra mocks base method.
func (m *MockChainLedger) GetBlockExtra(height uint64) (*types.BlockExtra, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockExtra", height)
	ret0, _ := ret[0].(*types.BlockExtra)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockExtra indicates an expected call of GetBlockExtra.
func (mr *MockChainLedgerMockRecorder) GetBlockExtra(height any) *MockChainLedgerGetBlockExtraCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockExtra", reflect.TypeOf((*MockChainLedger)(nil).GetBlockExtra), height)
	return &MockChainLedgerGetBlockExtraCall{Call: call}
}

// MockChainLedgerGetBlockExtraCall wrap *gomock.Call
type MockChainLedgerGetBlockExtraCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockExtraCall) Return(arg0 *types.BlockExtra, arg1 error) *MockChainLedgerGetBlockExtraCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockExtraCall) Do(f func(uint64) (*types.BlockExtra, error)) *MockChainLedgerGetBlockExtraCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockExtraCall) DoAndReturn(f func(uint64) (*types.BlockExtra, error)) *MockChainLedgerGetBlockExtraCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockHeader mocks base method.
func (m *MockChainLedger) GetBlockHeader(height uint64) (*types.BlockHeader, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockHeader", height)
	ret0, _ := ret[0].(*types.BlockHeader)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockHeader indicates an expected call of GetBlockHeader.
func (mr *MockChainLedgerMockRecorder) GetBlockHeader(height any) *MockChainLedgerGetBlockHeaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockHeader", reflect.TypeOf((*MockChainLedger)(nil).GetBlockHeader), height)
	return &MockChainLedgerGetBlockHeaderCall{Call: call}
}

// MockChainLedgerGetBlockHeaderCall wrap *gomock.Call
type MockChainLedgerGetBlockHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockHeaderCall) Return(arg0 *types.BlockHeader, arg1 error) *MockChainLedgerGetBlockHeaderCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockHeaderCall) Do(f func(uint64) (*types.BlockHeader, error)) *MockChainLedgerGetBlockHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockHeaderCall) DoAndReturn(f func(uint64) (*types.BlockHeader, error)) *MockChainLedgerGetBlockHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockNumberByHash mocks base method.
func (m *MockChainLedger) GetBlockNumberByHash(hash *types.Hash) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockNumberByHash", hash)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockNumberByHash indicates an expected call of GetBlockNumberByHash.
func (mr *MockChainLedgerMockRecorder) GetBlockNumberByHash(hash any) *MockChainLedgerGetBlockNumberByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockNumberByHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockNumberByHash), hash)
	return &MockChainLedgerGetBlockNumberByHashCall{Call: call}
}

// MockChainLedgerGetBlockNumberByHashCall wrap *gomock.Call
type MockChainLedgerGetBlockNumberByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockNumberByHashCall) Return(arg0 uint64, arg1 error) *MockChainLedgerGetBlockNumberByHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockNumberByHashCall) Do(f func(*types.Hash) (uint64, error)) *MockChainLedgerGetBlockNumberByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockNumberByHashCall) DoAndReturn(f func(*types.Hash) (uint64, error)) *MockChainLedgerGetBlockNumberByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockReceipts mocks base method.
func (m *MockChainLedger) GetBlockReceipts(height uint64) ([]*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockReceipts", height)
	ret0, _ := ret[0].([]*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockReceipts indicates an expected call of GetBlockReceipts.
func (mr *MockChainLedgerMockRecorder) GetBlockReceipts(height any) *MockChainLedgerGetBlockReceiptsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockReceipts", reflect.TypeOf((*MockChainLedger)(nil).GetBlockReceipts), height)
	return &MockChainLedgerGetBlockReceiptsCall{Call: call}
}

// MockChainLedgerGetBlockReceiptsCall wrap *gomock.Call
type MockChainLedgerGetBlockReceiptsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockReceiptsCall) Return(arg0 []*types.Receipt, arg1 error) *MockChainLedgerGetBlockReceiptsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockReceiptsCall) Do(f func(uint64) ([]*types.Receipt, error)) *MockChainLedgerGetBlockReceiptsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockReceiptsCall) DoAndReturn(f func(uint64) ([]*types.Receipt, error)) *MockChainLedgerGetBlockReceiptsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockTxHashList mocks base method.
func (m *MockChainLedger) GetBlockTxHashList(height uint64) ([]*types.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockTxHashList", height)
	ret0, _ := ret[0].([]*types.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockTxHashList indicates an expected call of GetBlockTxHashList.
func (mr *MockChainLedgerMockRecorder) GetBlockTxHashList(height any) *MockChainLedgerGetBlockTxHashListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockTxHashList", reflect.TypeOf((*MockChainLedger)(nil).GetBlockTxHashList), height)
	return &MockChainLedgerGetBlockTxHashListCall{Call: call}
}

// MockChainLedgerGetBlockTxHashListCall wrap *gomock.Call
type MockChainLedgerGetBlockTxHashListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockTxHashListCall) Return(arg0 []*types.Hash, arg1 error) *MockChainLedgerGetBlockTxHashListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockTxHashListCall) Do(f func(uint64) ([]*types.Hash, error)) *MockChainLedgerGetBlockTxHashListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockTxHashListCall) DoAndReturn(f func(uint64) ([]*types.Hash, error)) *MockChainLedgerGetBlockTxHashListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockTxList mocks base method.
func (m *MockChainLedger) GetBlockTxList(height uint64) ([]*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockTxList", height)
	ret0, _ := ret[0].([]*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockTxList indicates an expected call of GetBlockTxList.
func (mr *MockChainLedgerMockRecorder) GetBlockTxList(height any) *MockChainLedgerGetBlockTxListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockTxList", reflect.TypeOf((*MockChainLedger)(nil).GetBlockTxList), height)
	return &MockChainLedgerGetBlockTxListCall{Call: call}
}

// MockChainLedgerGetBlockTxListCall wrap *gomock.Call
type MockChainLedgerGetBlockTxListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetBlockTxListCall) Return(arg0 []*types.Transaction, arg1 error) *MockChainLedgerGetBlockTxListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetBlockTxListCall) Do(f func(uint64) ([]*types.Transaction, error)) *MockChainLedgerGetBlockTxListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetBlockTxListCall) DoAndReturn(f func(uint64) ([]*types.Transaction, error)) *MockChainLedgerGetBlockTxListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainMeta mocks base method.
func (m *MockChainLedger) GetChainMeta() *types.ChainMeta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	return ret0
}

// GetChainMeta indicates an expected call of GetChainMeta.
func (mr *MockChainLedgerMockRecorder) GetChainMeta() *MockChainLedgerGetChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainMeta", reflect.TypeOf((*MockChainLedger)(nil).GetChainMeta))
	return &MockChainLedgerGetChainMetaCall{Call: call}
}

// MockChainLedgerGetChainMetaCall wrap *gomock.Call
type MockChainLedgerGetChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetChainMetaCall) Return(arg0 *types.ChainMeta) *MockChainLedgerGetChainMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetChainMetaCall) Do(f func() *types.ChainMeta) *MockChainLedgerGetChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetChainMetaCall) DoAndReturn(f func() *types.ChainMeta) *MockChainLedgerGetChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReceipt mocks base method.
func (m *MockChainLedger) GetReceipt(hash *types.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReceipt", hash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReceipt indicates an expected call of GetReceipt.
func (mr *MockChainLedgerMockRecorder) GetReceipt(hash any) *MockChainLedgerGetReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceipt", reflect.TypeOf((*MockChainLedger)(nil).GetReceipt), hash)
	return &MockChainLedgerGetReceiptCall{Call: call}
}

// MockChainLedgerGetReceiptCall wrap *gomock.Call
type MockChainLedgerGetReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetReceiptCall) Return(arg0 *types.Receipt, arg1 error) *MockChainLedgerGetReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetReceiptCall) Do(f func(*types.Hash) (*types.Receipt, error)) *MockChainLedgerGetReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetReceiptCall) DoAndReturn(f func(*types.Hash) (*types.Receipt, error)) *MockChainLedgerGetReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *MockChainLedger) GetTransaction(hash *types.Hash) (*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", hash)
	ret0, _ := ret[0].(*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *MockChainLedgerMockRecorder) GetTransaction(hash any) *MockChainLedgerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockChainLedger)(nil).GetTransaction), hash)
	return &MockChainLedgerGetTransactionCall{Call: call}
}

// MockChainLedgerGetTransactionCall wrap *gomock.Call
type MockChainLedgerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetTransactionCall) Return(arg0 *types.Transaction, arg1 error) *MockChainLedgerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetTransactionCall) Do(f func(*types.Hash) (*types.Transaction, error)) *MockChainLedgerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetTransactionCall) DoAndReturn(f func(*types.Hash) (*types.Transaction, error)) *MockChainLedgerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionCount mocks base method.
func (m *MockChainLedger) GetTransactionCount(height uint64) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionCount", height)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionCount indicates an expected call of GetTransactionCount.
func (mr *MockChainLedgerMockRecorder) GetTransactionCount(height any) *MockChainLedgerGetTransactionCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionCount", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionCount), height)
	return &MockChainLedgerGetTransactionCountCall{Call: call}
}

// MockChainLedgerGetTransactionCountCall wrap *gomock.Call
type MockChainLedgerGetTransactionCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetTransactionCountCall) Return(arg0 uint64, arg1 error) *MockChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetTransactionCountCall) Do(f func(uint64) (uint64, error)) *MockChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetTransactionCountCall) DoAndReturn(f func(uint64) (uint64, error)) *MockChainLedgerGetTransactionCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionMeta mocks base method.
func (m *MockChainLedger) GetTransactionMeta(hash *types.Hash) (*types.TransactionMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionMeta", hash)
	ret0, _ := ret[0].(*types.TransactionMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionMeta indicates an expected call of GetTransactionMeta.
func (mr *MockChainLedgerMockRecorder) GetTransactionMeta(hash any) *MockChainLedgerGetTransactionMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionMeta", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionMeta), hash)
	return &MockChainLedgerGetTransactionMetaCall{Call: call}
}

// MockChainLedgerGetTransactionMetaCall wrap *gomock.Call
type MockChainLedgerGetTransactionMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerGetTransactionMetaCall) Return(arg0 *types.TransactionMeta, arg1 error) *MockChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerGetTransactionMetaCall) Do(f func(*types.Hash) (*types.TransactionMeta, error)) *MockChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerGetTransactionMetaCall) DoAndReturn(f func(*types.Hash) (*types.TransactionMeta, error)) *MockChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoadChainMeta mocks base method.
func (m *MockChainLedger) LoadChainMeta() (*types.ChainMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadChainMeta indicates an expected call of LoadChainMeta.
func (mr *MockChainLedgerMockRecorder) LoadChainMeta() *MockChainLedgerLoadChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadChainMeta", reflect.TypeOf((*MockChainLedger)(nil).LoadChainMeta))
	return &MockChainLedgerLoadChainMetaCall{Call: call}
}

// MockChainLedgerLoadChainMetaCall wrap *gomock.Call
type MockChainLedgerLoadChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerLoadChainMetaCall) Return(arg0 *types.ChainMeta, arg1 error) *MockChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerLoadChainMetaCall) Do(f func() (*types.ChainMeta, error)) *MockChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerLoadChainMetaCall) DoAndReturn(f func() (*types.ChainMeta, error)) *MockChainLedgerLoadChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PersistExecutionResult mocks base method.
func (m *MockChainLedger) PersistExecutionResult(block *types.Block, receipts []*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PersistExecutionResult", block, receipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// PersistExecutionResult indicates an expected call of PersistExecutionResult.
func (mr *MockChainLedgerMockRecorder) PersistExecutionResult(block, receipts any) *MockChainLedgerPersistExecutionResultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistExecutionResult", reflect.TypeOf((*MockChainLedger)(nil).PersistExecutionResult), block, receipts)
	return &MockChainLedgerPersistExecutionResultCall{Call: call}
}

// MockChainLedgerPersistExecutionResultCall wrap *gomock.Call
type MockChainLedgerPersistExecutionResultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerPersistExecutionResultCall) Return(arg0 error) *MockChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerPersistExecutionResultCall) Do(f func(*types.Block, []*types.Receipt) error) *MockChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerPersistExecutionResultCall) DoAndReturn(f func(*types.Block, []*types.Receipt) error) *MockChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlockChain mocks base method.
func (m *MockChainLedger) RollbackBlockChain(height uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlockChain", height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBlockChain indicates an expected call of RollbackBlockChain.
func (mr *MockChainLedgerMockRecorder) RollbackBlockChain(height any) *MockChainLedgerRollbackBlockChainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlockChain", reflect.TypeOf((*MockChainLedger)(nil).RollbackBlockChain), height)
	return &MockChainLedgerRollbackBlockChainCall{Call: call}
}

// MockChainLedgerRollbackBlockChainCall wrap *gomock.Call
type MockChainLedgerRollbackBlockChainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerRollbackBlockChainCall) Return(arg0 error) *MockChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerRollbackBlockChainCall) Do(f func(uint64) error) *MockChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerRollbackBlockChainCall) DoAndReturn(f func(uint64) error) *MockChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainMeta mocks base method.
func (m *MockChainLedger) UpdateChainMeta(arg0 *types.ChainMeta) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainMeta", arg0)
}

// UpdateChainMeta indicates an expected call of UpdateChainMeta.
func (mr *MockChainLedgerMockRecorder) UpdateChainMeta(arg0 any) *MockChainLedgerUpdateChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainMeta", reflect.TypeOf((*MockChainLedger)(nil).UpdateChainMeta), arg0)
	return &MockChainLedgerUpdateChainMetaCall{Call: call}
}

// MockChainLedgerUpdateChainMetaCall wrap *gomock.Call
type MockChainLedgerUpdateChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockChainLedgerUpdateChainMetaCall) Return() *MockChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockChainLedgerUpdateChainMetaCall) Do(f func(*types.ChainMeta)) *MockChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockChainLedgerUpdateChainMetaCall) DoAndReturn(f func(*types.ChainMeta)) *MockChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateLedger is a mock of StateLedger interface.
type MockStateLedger struct {
	ctrl     *gomock.Controller
	recorder *MockStateLedgerMockRecorder
}

// MockStateLedgerMockRecorder is the mock recorder for MockStateLedger.
type MockStateLedgerMockRecorder struct {
	mock *MockStateLedger
}

// NewMockStateLedger creates a new mock instance.
func NewMockStateLedger(ctrl *gomock.Controller) *MockStateLedger {
	mock := &MockStateLedger{ctrl: ctrl}
	mock.recorder = &MockStateLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateLedger) EXPECT() *MockStateLedgerMockRecorder {
	return m.recorder
}

// AddAddressToAccessList mocks base method.
func (m *MockStateLedger) AddAddressToAccessList(arg0 types.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAddressToAccessList", arg0)
}

// AddAddressToAccessList indicates an expected call of AddAddressToAccessList.
func (mr *MockStateLedgerMockRecorder) AddAddressToAccessList(arg0 any) *MockStateLedgerAddAddressToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAddressToAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddAddressToAccessList), arg0)
	return &MockStateLedgerAddAddressToAccessListCall{Call: call}
}

// MockStateLedgerAddAddressToAccessListCall wrap *gomock.Call
type MockStateLedgerAddAddressToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddAddressToAccessListCall) Return() *MockStateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddAddressToAccessListCall) Do(f func(types.Address)) *MockStateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddAddressToAccessListCall) DoAndReturn(f func(types.Address)) *MockStateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddBalance mocks base method.
func (m *MockStateLedger) AddBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", arg0, arg1)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockStateLedgerMockRecorder) AddBalance(arg0, arg1 any) *MockStateLedgerAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockStateLedger)(nil).AddBalance), arg0, arg1)
	return &MockStateLedgerAddBalanceCall{Call: call}
}

// MockStateLedgerAddBalanceCall wrap *gomock.Call
type MockStateLedgerAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddBalanceCall) Return() *MockStateLedgerAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateLedgerAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateLedgerAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddLog mocks base method.
func (m *MockStateLedger) AddLog(log *types.EvmLog) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddLog", log)
}

// AddLog indicates an expected call of AddLog.
func (mr *MockStateLedgerMockRecorder) AddLog(log any) *MockStateLedgerAddLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLog", reflect.TypeOf((*MockStateLedger)(nil).AddLog), log)
	return &MockStateLedgerAddLogCall{Call: call}
}

// MockStateLedgerAddLogCall wrap *gomock.Call
type MockStateLedgerAddLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddLogCall) Return() *MockStateLedgerAddLogCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddLogCall) Do(f func(*types.EvmLog)) *MockStateLedgerAddLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddLogCall) DoAndReturn(f func(*types.EvmLog)) *MockStateLedgerAddLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPreimage mocks base method.
func (m *MockStateLedger) AddPreimage(arg0 types.Hash, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreimage", arg0, arg1)
}

// AddPreimage indicates an expected call of AddPreimage.
func (mr *MockStateLedgerMockRecorder) AddPreimage(arg0, arg1 any) *MockStateLedgerAddPreimageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreimage", reflect.TypeOf((*MockStateLedger)(nil).AddPreimage), arg0, arg1)
	return &MockStateLedgerAddPreimageCall{Call: call}
}

// MockStateLedgerAddPreimageCall wrap *gomock.Call
type MockStateLedgerAddPreimageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddPreimageCall) Return() *MockStateLedgerAddPreimageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddPreimageCall) Do(f func(types.Hash, []byte)) *MockStateLedgerAddPreimageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddPreimageCall) DoAndReturn(f func(types.Hash, []byte)) *MockStateLedgerAddPreimageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRefund mocks base method.
func (m *MockStateLedger) AddRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRefund", arg0)
}

// AddRefund indicates an expected call of AddRefund.
func (mr *MockStateLedgerMockRecorder) AddRefund(arg0 any) *MockStateLedgerAddRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRefund", reflect.TypeOf((*MockStateLedger)(nil).AddRefund), arg0)
	return &MockStateLedgerAddRefundCall{Call: call}
}

// MockStateLedgerAddRefundCall wrap *gomock.Call
type MockStateLedgerAddRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddRefundCall) Return() *MockStateLedgerAddRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddRefundCall) Do(f func(uint64)) *MockStateLedgerAddRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddRefundCall) DoAndReturn(f func(uint64)) *MockStateLedgerAddRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSlotToAccessList mocks base method.
func (m *MockStateLedger) AddSlotToAccessList(arg0 types.Address, arg1 types.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSlotToAccessList", arg0, arg1)
}

// AddSlotToAccessList indicates an expected call of AddSlotToAccessList.
func (mr *MockStateLedgerMockRecorder) AddSlotToAccessList(arg0, arg1 any) *MockStateLedgerAddSlotToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSlotToAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddSlotToAccessList), arg0, arg1)
	return &MockStateLedgerAddSlotToAccessListCall{Call: call}
}

// MockStateLedgerAddSlotToAccessListCall wrap *gomock.Call
type MockStateLedgerAddSlotToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddSlotToAccessListCall) Return() *MockStateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddSlotToAccessListCall) Do(f func(types.Address, types.Hash)) *MockStateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddSlotToAccessListCall) DoAndReturn(f func(types.Address, types.Hash)) *MockStateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddressInAccessList mocks base method.
func (m *MockStateLedger) AddressInAccessList(arg0 types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddressInAccessList", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// AddressInAccessList indicates an expected call of AddressInAccessList.
func (mr *MockStateLedgerMockRecorder) AddressInAccessList(arg0 any) *MockStateLedgerAddressInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddressInAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddressInAccessList), arg0)
	return &MockStateLedgerAddressInAccessListCall{Call: call}
}

// MockStateLedgerAddressInAccessListCall wrap *gomock.Call
type MockStateLedgerAddressInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerAddressInAccessListCall) Return(arg0 bool) *MockStateLedgerAddressInAccessListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerAddressInAccessListCall) Do(f func(types.Address) bool) *MockStateLedgerAddressInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerAddressInAccessListCall) DoAndReturn(f func(types.Address) bool) *MockStateLedgerAddressInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Clear mocks base method.
func (m *MockStateLedger) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateLedgerMockRecorder) Clear() *MockStateLedgerClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateLedger)(nil).Clear))
	return &MockStateLedgerClearCall{Call: call}
}

// MockStateLedgerClearCall wrap *gomock.Call
type MockStateLedgerClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerClearCall) Return() *MockStateLedgerClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerClearCall) Do(f func()) *MockStateLedgerClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerClearCall) DoAndReturn(f func()) *MockStateLedgerClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearChangerAndRefund mocks base method.
func (m *MockStateLedger) ClearChangerAndRefund() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ClearChangerAndRefund")
}

// ClearChangerAndRefund indicates an expected call of ClearChangerAndRefund.
func (mr *MockStateLedgerMockRecorder) ClearChangerAndRefund() *MockStateLedgerClearChangerAndRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearChangerAndRefund", reflect.TypeOf((*MockStateLedger)(nil).ClearChangerAndRefund))
	return &MockStateLedgerClearChangerAndRefundCall{Call: call}
}

// MockStateLedgerClearChangerAndRefundCall wrap *gomock.Call
type MockStateLedgerClearChangerAndRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerClearChangerAndRefundCall) Return() *MockStateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerClearChangerAndRefundCall) Do(f func()) *MockStateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerClearChangerAndRefundCall) DoAndReturn(f func()) *MockStateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockStateLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockStateLedgerMockRecorder) Close() *MockStateLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStateLedger)(nil).Close))
	return &MockStateLedgerCloseCall{Call: call}
}

// MockStateLedgerCloseCall wrap *gomock.Call
type MockStateLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerCloseCall) Return() *MockStateLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerCloseCall) Do(f func()) *MockStateLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerCloseCall) DoAndReturn(f func()) *MockStateLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateLedger) Commit() (*types.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(*types.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockStateLedgerMockRecorder) Commit() *MockStateLedgerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateLedger)(nil).Commit))
	return &MockStateLedgerCommitCall{Call: call}
}

// MockStateLedgerCommitCall wrap *gomock.Call
type MockStateLedgerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerCommitCall) Return(arg0 *types.Hash, arg1 error) *MockStateLedgerCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerCommitCall) Do(f func() (*types.Hash, error)) *MockStateLedgerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerCommitCall) DoAndReturn(f func() (*types.Hash, error)) *MockStateLedgerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CurrentBlockHeight mocks base method.
func (m *MockStateLedger) CurrentBlockHeight() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CurrentBlockHeight")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// CurrentBlockHeight indicates an expected call of CurrentBlockHeight.
func (mr *MockStateLedgerMockRecorder) CurrentBlockHeight() *MockStateLedgerCurrentBlockHeightCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CurrentBlockHeight", reflect.TypeOf((*MockStateLedger)(nil).CurrentBlockHeight))
	return &MockStateLedgerCurrentBlockHeightCall{Call: call}
}

// MockStateLedgerCurrentBlockHeightCall wrap *gomock.Call
type MockStateLedgerCurrentBlockHeightCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerCurrentBlockHeightCall) Return(arg0 uint64) *MockStateLedgerCurrentBlockHeightCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerCurrentBlockHeightCall) Do(f func() uint64) *MockStateLedgerCurrentBlockHeightCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerCurrentBlockHeightCall) DoAndReturn(f func() uint64) *MockStateLedgerCurrentBlockHeightCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Empty mocks base method.
func (m *MockStateLedger) Empty(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty.
func (mr *MockStateLedgerMockRecorder) Empty(arg0 any) *MockStateLedgerEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockStateLedger)(nil).Empty), arg0)
	return &MockStateLedgerEmptyCall{Call: call}
}

// MockStateLedgerEmptyCall wrap *gomock.Call
type MockStateLedgerEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerEmptyCall) Return(arg0 bool) *MockStateLedgerEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerEmptyCall) Do(f func(*types.Address) bool) *MockStateLedgerEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerEmptyCall) DoAndReturn(f func(*types.Address) bool) *MockStateLedgerEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exist mocks base method.
func (m *MockStateLedger) Exist(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockStateLedgerMockRecorder) Exist(arg0 any) *MockStateLedgerExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStateLedger)(nil).Exist), arg0)
	return &MockStateLedgerExistCall{Call: call}
}

// MockStateLedgerExistCall wrap *gomock.Call
type MockStateLedgerExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerExistCall) Return(arg0 bool) *MockStateLedgerExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerExistCall) Do(f func(*types.Address) bool) *MockStateLedgerExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerExistCall) DoAndReturn(f func(*types.Address) bool) *MockStateLedgerExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockStateLedger) Finalise() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Finalise")
}

// Finalise indicates an expected call of Finalise.
func (mr *MockStateLedgerMockRecorder) Finalise() *MockStateLedgerFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockStateLedger)(nil).Finalise))
	return &MockStateLedgerFinaliseCall{Call: call}
}

// MockStateLedgerFinaliseCall wrap *gomock.Call
type MockStateLedgerFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerFinaliseCall) Return() *MockStateLedgerFinaliseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerFinaliseCall) Do(f func()) *MockStateLedgerFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerFinaliseCall) DoAndReturn(f func()) *MockStateLedgerFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateSnapshot mocks base method.
func (m *MockStateLedger) GenerateSnapshot(blockHeader *types.BlockHeader, errC chan error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "GenerateSnapshot", blockHeader, errC)
}

// GenerateSnapshot indicates an expected call of GenerateSnapshot.
func (mr *MockStateLedgerMockRecorder) GenerateSnapshot(blockHeader, errC any) *MockStateLedgerGenerateSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateSnapshot", reflect.TypeOf((*MockStateLedger)(nil).GenerateSnapshot), blockHeader, errC)
	return &MockStateLedgerGenerateSnapshotCall{Call: call}
}

// MockStateLedgerGenerateSnapshotCall wrap *gomock.Call
type MockStateLedgerGenerateSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGenerateSnapshotCall) Return() *MockStateLedgerGenerateSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGenerateSnapshotCall) Do(f func(*types.BlockHeader, chan error)) *MockStateLedgerGenerateSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGenerateSnapshotCall) DoAndReturn(f func(*types.BlockHeader, chan error)) *MockStateLedgerGenerateSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateLedger) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateLedgerMockRecorder) GetAccount(arg0 any) *MockStateLedgerGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateLedger)(nil).GetAccount), arg0)
	return &MockStateLedgerGetAccountCall{Call: call}
}

// MockStateLedgerGetAccountCall wrap *gomock.Call
type MockStateLedgerGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetAccountCall) Return(arg0 ledger.IAccount) *MockStateLedgerGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *MockStateLedgerGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *MockStateLedgerGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateLedger) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateLedgerMockRecorder) GetBalance(arg0 any) *MockStateLedgerGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateLedger)(nil).GetBalance), arg0)
	return &MockStateLedgerGetBalanceCall{Call: call}
}

// MockStateLedgerGetBalanceCall wrap *gomock.Call
type MockStateLedgerGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetBalanceCall) Return(arg0 *big.Int) *MockStateLedgerGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetBalanceCall) Do(f func(*types.Address) *big.Int) *MockStateLedgerGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *MockStateLedgerGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateLedger) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateLedgerMockRecorder) GetCode(arg0 any) *MockStateLedgerGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateLedger)(nil).GetCode), arg0)
	return &MockStateLedgerGetCodeCall{Call: call}
}

// MockStateLedgerGetCodeCall wrap *gomock.Call
type MockStateLedgerGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetCodeCall) Return(arg0 []byte) *MockStateLedgerGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetCodeCall) Do(f func(*types.Address) []byte) *MockStateLedgerGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *MockStateLedgerGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeHash mocks base method.
func (m *MockStateLedger) GetCodeHash(arg0 *types.Address) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeHash", arg0)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetCodeHash indicates an expected call of GetCodeHash.
func (mr *MockStateLedgerMockRecorder) GetCodeHash(arg0 any) *MockStateLedgerGetCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeHash", reflect.TypeOf((*MockStateLedger)(nil).GetCodeHash), arg0)
	return &MockStateLedgerGetCodeHashCall{Call: call}
}

// MockStateLedgerGetCodeHashCall wrap *gomock.Call
type MockStateLedgerGetCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetCodeHashCall) Return(arg0 *types.Hash) *MockStateLedgerGetCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetCodeHashCall) Do(f func(*types.Address) *types.Hash) *MockStateLedgerGetCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetCodeHashCall) DoAndReturn(f func(*types.Address) *types.Hash) *MockStateLedgerGetCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeSize mocks base method.
func (m *MockStateLedger) GetCodeSize(arg0 *types.Address) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeSize", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetCodeSize indicates an expected call of GetCodeSize.
func (mr *MockStateLedgerMockRecorder) GetCodeSize(arg0 any) *MockStateLedgerGetCodeSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeSize", reflect.TypeOf((*MockStateLedger)(nil).GetCodeSize), arg0)
	return &MockStateLedgerGetCodeSizeCall{Call: call}
}

// MockStateLedgerGetCodeSizeCall wrap *gomock.Call
type MockStateLedgerGetCodeSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetCodeSizeCall) Return(arg0 int) *MockStateLedgerGetCodeSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetCodeSizeCall) Do(f func(*types.Address) int) *MockStateLedgerGetCodeSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetCodeSizeCall) DoAndReturn(f func(*types.Address) int) *MockStateLedgerGetCodeSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockStateLedger) GetCommittedState(arg0 *types.Address, arg1 []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockStateLedgerMockRecorder) GetCommittedState(arg0, arg1 any) *MockStateLedgerGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockStateLedger)(nil).GetCommittedState), arg0, arg1)
	return &MockStateLedgerGetCommittedStateCall{Call: call}
}

// MockStateLedgerGetCommittedStateCall wrap *gomock.Call
type MockStateLedgerGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetCommittedStateCall) Return(arg0 []byte) *MockStateLedgerGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetCommittedStateCall) Do(f func(*types.Address, []byte) []byte) *MockStateLedgerGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetCommittedStateCall) DoAndReturn(f func(*types.Address, []byte) []byte) *MockStateLedgerGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetHistoryRange mocks base method.
func (m *MockStateLedger) GetHistoryRange() (uint64, uint64) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHistoryRange")
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	return ret0, ret1
}

// GetHistoryRange indicates an expected call of GetHistoryRange.
func (mr *MockStateLedgerMockRecorder) GetHistoryRange() *MockStateLedgerGetHistoryRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHistoryRange", reflect.TypeOf((*MockStateLedger)(nil).GetHistoryRange))
	return &MockStateLedgerGetHistoryRangeCall{Call: call}
}

// MockStateLedgerGetHistoryRangeCall wrap *gomock.Call
type MockStateLedgerGetHistoryRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetHistoryRangeCall) Return(arg0, arg1 uint64) *MockStateLedgerGetHistoryRangeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetHistoryRangeCall) Do(f func() (uint64, uint64)) *MockStateLedgerGetHistoryRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetHistoryRangeCall) DoAndReturn(f func() (uint64, uint64)) *MockStateLedgerGetHistoryRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLogs mocks base method.
func (m *MockStateLedger) GetLogs(txHash types.Hash, height uint64) []*types.EvmLog {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", txHash, height)
	ret0, _ := ret[0].([]*types.EvmLog)
	return ret0
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockStateLedgerMockRecorder) GetLogs(txHash, height any) *MockStateLedgerGetLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockStateLedger)(nil).GetLogs), txHash, height)
	return &MockStateLedgerGetLogsCall{Call: call}
}

// MockStateLedgerGetLogsCall wrap *gomock.Call
type MockStateLedgerGetLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetLogsCall) Return(arg0 []*types.EvmLog) *MockStateLedgerGetLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetLogsCall) Do(f func(types.Hash, uint64) []*types.EvmLog) *MockStateLedgerGetLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetLogsCall) DoAndReturn(f func(types.Hash, uint64) []*types.EvmLog) *MockStateLedgerGetLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateLedger) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateLedgerMockRecorder) GetNonce(arg0 any) *MockStateLedgerGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateLedger)(nil).GetNonce), arg0)
	return &MockStateLedgerGetNonceCall{Call: call}
}

// MockStateLedgerGetNonceCall wrap *gomock.Call
type MockStateLedgerGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetNonceCall) Return(arg0 uint64) *MockStateLedgerGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetNonceCall) Do(f func(*types.Address) uint64) *MockStateLedgerGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *MockStateLedgerGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateLedger) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateLedgerMockRecorder) GetOrCreateAccount(arg0 any) *MockStateLedgerGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateLedger)(nil).GetOrCreateAccount), arg0)
	return &MockStateLedgerGetOrCreateAccountCall{Call: call}
}

// MockStateLedgerGetOrCreateAccountCall wrap *gomock.Call
type MockStateLedgerGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *MockStateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *MockStateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *MockStateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRefund mocks base method.
func (m *MockStateLedger) GetRefund() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRefund")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetRefund indicates an expected call of GetRefund.
func (mr *MockStateLedgerMockRecorder) GetRefund() *MockStateLedgerGetRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRefund", reflect.TypeOf((*MockStateLedger)(nil).GetRefund))
	return &MockStateLedgerGetRefundCall{Call: call}
}

// MockStateLedgerGetRefundCall wrap *gomock.Call
type MockStateLedgerGetRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetRefundCall) Return(arg0 uint64) *MockStateLedgerGetRefundCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetRefundCall) Do(f func() uint64) *MockStateLedgerGetRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetRefundCall) DoAndReturn(f func() uint64) *MockStateLedgerGetRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateLedger) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateLedgerMockRecorder) GetState(arg0, arg1 any) *MockStateLedgerGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateLedger)(nil).GetState), arg0, arg1)
	return &MockStateLedgerGetStateCall{Call: call}
}

// MockStateLedgerGetStateCall wrap *gomock.Call
type MockStateLedgerGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetStateCall) Return(arg0 bool, arg1 []byte) *MockStateLedgerGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *MockStateLedgerGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *MockStateLedgerGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTrieSnapshotMeta mocks base method.
func (m *MockStateLedger) GetTrieSnapshotMeta() (*ledger.SnapshotMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTrieSnapshotMeta")
	ret0, _ := ret[0].(*ledger.SnapshotMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTrieSnapshotMeta indicates an expected call of GetTrieSnapshotMeta.
func (mr *MockStateLedgerMockRecorder) GetTrieSnapshotMeta() *MockStateLedgerGetTrieSnapshotMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrieSnapshotMeta", reflect.TypeOf((*MockStateLedger)(nil).GetTrieSnapshotMeta))
	return &MockStateLedgerGetTrieSnapshotMetaCall{Call: call}
}

// MockStateLedgerGetTrieSnapshotMetaCall wrap *gomock.Call
type MockStateLedgerGetTrieSnapshotMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerGetTrieSnapshotMetaCall) Return(arg0 *ledger.SnapshotMeta, arg1 error) *MockStateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerGetTrieSnapshotMetaCall) Do(f func() (*ledger.SnapshotMeta, error)) *MockStateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerGetTrieSnapshotMetaCall) DoAndReturn(f func() (*ledger.SnapshotMeta, error)) *MockStateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasSuicide mocks base method.
func (m *MockStateLedger) HasSuicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSuicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSuicide indicates an expected call of HasSuicide.
func (mr *MockStateLedgerMockRecorder) HasSuicide(arg0 any) *MockStateLedgerHasSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSuicide", reflect.TypeOf((*MockStateLedger)(nil).HasSuicide), arg0)
	return &MockStateLedgerHasSuicideCall{Call: call}
}

// MockStateLedgerHasSuicideCall wrap *gomock.Call
type MockStateLedgerHasSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerHasSuicideCall) Return(arg0 bool) *MockStateLedgerHasSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerHasSuicideCall) Do(f func(*types.Address) bool) *MockStateLedgerHasSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerHasSuicideCall) DoAndReturn(f func(*types.Address) bool) *MockStateLedgerHasSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IterateTrie mocks base method.
func (m *MockStateLedger) IterateTrie(snapshotMeta *ledger.SnapshotMeta, kv kv.Storage, errC chan error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "IterateTrie", snapshotMeta, kv, errC)
}

// IterateTrie indicates an expected call of IterateTrie.
func (mr *MockStateLedgerMockRecorder) IterateTrie(snapshotMeta, kv, errC any) *MockStateLedgerIterateTrieCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IterateTrie", reflect.TypeOf((*MockStateLedger)(nil).IterateTrie), snapshotMeta, kv, errC)
	return &MockStateLedgerIterateTrieCall{Call: call}
}

// MockStateLedgerIterateTrieCall wrap *gomock.Call
type MockStateLedgerIterateTrieCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerIterateTrieCall) Return() *MockStateLedgerIterateTrieCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerIterateTrieCall) Do(f func(*ledger.SnapshotMeta, kv.Storage, chan error)) *MockStateLedgerIterateTrieCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerIterateTrieCall) DoAndReturn(f func(*ledger.SnapshotMeta, kv.Storage, chan error)) *MockStateLedgerIterateTrieCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewView mocks base method.
func (m *MockStateLedger) NewView(blockHeader *types.BlockHeader, enableSnapshot bool) (ledger.StateLedger, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewView", blockHeader, enableSnapshot)
	ret0, _ := ret[0].(ledger.StateLedger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewView indicates an expected call of NewView.
func (mr *MockStateLedgerMockRecorder) NewView(blockHeader, enableSnapshot any) *MockStateLedgerNewViewCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewView", reflect.TypeOf((*MockStateLedger)(nil).NewView), blockHeader, enableSnapshot)
	return &MockStateLedgerNewViewCall{Call: call}
}

// MockStateLedgerNewViewCall wrap *gomock.Call
type MockStateLedgerNewViewCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerNewViewCall) Return(arg0 ledger.StateLedger, arg1 error) *MockStateLedgerNewViewCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerNewViewCall) Do(f func(*types.BlockHeader, bool) (ledger.StateLedger, error)) *MockStateLedgerNewViewCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerNewViewCall) DoAndReturn(f func(*types.BlockHeader, bool) (ledger.StateLedger, error)) *MockStateLedgerNewViewCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewViewWithoutCache mocks base method.
func (m *MockStateLedger) NewViewWithoutCache(blockHeader *types.BlockHeader, enableSnapshot bool) (ledger.StateLedger, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewViewWithoutCache", blockHeader, enableSnapshot)
	ret0, _ := ret[0].(ledger.StateLedger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewViewWithoutCache indicates an expected call of NewViewWithoutCache.
func (mr *MockStateLedgerMockRecorder) NewViewWithoutCache(blockHeader, enableSnapshot any) *MockStateLedgerNewViewWithoutCacheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewViewWithoutCache", reflect.TypeOf((*MockStateLedger)(nil).NewViewWithoutCache), blockHeader, enableSnapshot)
	return &MockStateLedgerNewViewWithoutCacheCall{Call: call}
}

// MockStateLedgerNewViewWithoutCacheCall wrap *gomock.Call
type MockStateLedgerNewViewWithoutCacheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerNewViewWithoutCacheCall) Return(arg0 ledger.StateLedger, arg1 error) *MockStateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerNewViewWithoutCacheCall) Do(f func(*types.BlockHeader, bool) (ledger.StateLedger, error)) *MockStateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerNewViewWithoutCacheCall) DoAndReturn(f func(*types.BlockHeader, bool) (ledger.StateLedger, error)) *MockStateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareBlock mocks base method.
func (m *MockStateLedger) PrepareBlock(lastStateRoot *types.Hash, currentExecutingHeight uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PrepareBlock", lastStateRoot, currentExecutingHeight)
}

// PrepareBlock indicates an expected call of PrepareBlock.
func (mr *MockStateLedgerMockRecorder) PrepareBlock(lastStateRoot, currentExecutingHeight any) *MockStateLedgerPrepareBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareBlock", reflect.TypeOf((*MockStateLedger)(nil).PrepareBlock), lastStateRoot, currentExecutingHeight)
	return &MockStateLedgerPrepareBlockCall{Call: call}
}

// MockStateLedgerPrepareBlockCall wrap *gomock.Call
type MockStateLedgerPrepareBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerPrepareBlockCall) Return() *MockStateLedgerPrepareBlockCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerPrepareBlockCall) Do(f func(*types.Hash, uint64)) *MockStateLedgerPrepareBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerPrepareBlockCall) DoAndReturn(f func(*types.Hash, uint64)) *MockStateLedgerPrepareBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prove mocks base method.
func (m *MockStateLedger) Prove(rootHash common.Hash, key []byte) (*jmt.ProofResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prove", rootHash, key)
	ret0, _ := ret[0].(*jmt.ProofResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prove indicates an expected call of Prove.
func (mr *MockStateLedgerMockRecorder) Prove(rootHash, key any) *MockStateLedgerProveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prove", reflect.TypeOf((*MockStateLedger)(nil).Prove), rootHash, key)
	return &MockStateLedgerProveCall{Call: call}
}

// MockStateLedgerProveCall wrap *gomock.Call
type MockStateLedgerProveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerProveCall) Return(arg0 *jmt.ProofResult, arg1 error) *MockStateLedgerProveCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerProveCall) Do(f func(common.Hash, []byte) (*jmt.ProofResult, error)) *MockStateLedgerProveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerProveCall) DoAndReturn(f func(common.Hash, []byte) (*jmt.ProofResult, error)) *MockStateLedgerProveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertToSnapshot mocks base method.
func (m *MockStateLedger) RevertToSnapshot(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RevertToSnapshot", arg0)
}

// RevertToSnapshot indicates an expected call of RevertToSnapshot.
func (mr *MockStateLedgerMockRecorder) RevertToSnapshot(arg0 any) *MockStateLedgerRevertToSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertToSnapshot", reflect.TypeOf((*MockStateLedger)(nil).RevertToSnapshot), arg0)
	return &MockStateLedgerRevertToSnapshotCall{Call: call}
}

// MockStateLedgerRevertToSnapshotCall wrap *gomock.Call
type MockStateLedgerRevertToSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerRevertToSnapshotCall) Return() *MockStateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerRevertToSnapshotCall) Do(f func(int)) *MockStateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerRevertToSnapshotCall) DoAndReturn(f func(int)) *MockStateLedgerRevertToSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackState mocks base method.
func (m *MockStateLedger) RollbackState(height uint64, lastStateRoot *types.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackState", height, lastStateRoot)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackState indicates an expected call of RollbackState.
func (mr *MockStateLedgerMockRecorder) RollbackState(height, lastStateRoot any) *MockStateLedgerRollbackStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackState", reflect.TypeOf((*MockStateLedger)(nil).RollbackState), height, lastStateRoot)
	return &MockStateLedgerRollbackStateCall{Call: call}
}

// MockStateLedgerRollbackStateCall wrap *gomock.Call
type MockStateLedgerRollbackStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerRollbackStateCall) Return(arg0 error) *MockStateLedgerRollbackStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerRollbackStateCall) Do(f func(uint64, *types.Hash) error) *MockStateLedgerRollbackStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerRollbackStateCall) DoAndReturn(f func(uint64, *types.Hash) error) *MockStateLedgerRollbackStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateLedger) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateLedgerMockRecorder) SetBalance(arg0, arg1 any) *MockStateLedgerSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateLedger)(nil).SetBalance), arg0, arg1)
	return &MockStateLedgerSetBalanceCall{Call: call}
}

// MockStateLedgerSetBalanceCall wrap *gomock.Call
type MockStateLedgerSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSetBalanceCall) Return() *MockStateLedgerSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSetBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateLedgerSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateLedgerSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateLedger) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateLedgerMockRecorder) SetCode(arg0, arg1 any) *MockStateLedgerSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateLedger)(nil).SetCode), arg0, arg1)
	return &MockStateLedgerSetCodeCall{Call: call}
}

// MockStateLedgerSetCodeCall wrap *gomock.Call
type MockStateLedgerSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSetCodeCall) Return() *MockStateLedgerSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSetCodeCall) Do(f func(*types.Address, []byte)) *MockStateLedgerSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *MockStateLedgerSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateLedger) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateLedgerMockRecorder) SetNonce(arg0, arg1 any) *MockStateLedgerSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateLedger)(nil).SetNonce), arg0, arg1)
	return &MockStateLedgerSetNonceCall{Call: call}
}

// MockStateLedgerSetNonceCall wrap *gomock.Call
type MockStateLedgerSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSetNonceCall) Return() *MockStateLedgerSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSetNonceCall) Do(f func(*types.Address, uint64)) *MockStateLedgerSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *MockStateLedgerSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateLedger) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateLedgerMockRecorder) SetState(arg0, arg1, arg2 any) *MockStateLedgerSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateLedger)(nil).SetState), arg0, arg1, arg2)
	return &MockStateLedgerSetStateCall{Call: call}
}

// MockStateLedgerSetStateCall wrap *gomock.Call
type MockStateLedgerSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSetStateCall) Return() *MockStateLedgerSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSetStateCall) Do(f func(*types.Address, []byte, []byte)) *MockStateLedgerSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *MockStateLedgerSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateLedger) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateLedgerMockRecorder) SetTxContext(thash, txIndex any) *MockStateLedgerSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateLedger)(nil).SetTxContext), thash, txIndex)
	return &MockStateLedgerSetTxContextCall{Call: call}
}

// MockStateLedgerSetTxContextCall wrap *gomock.Call
type MockStateLedgerSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSetTxContextCall) Return() *MockStateLedgerSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSetTxContextCall) Do(f func(*types.Hash, int)) *MockStateLedgerSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *MockStateLedgerSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlotInAccessList mocks base method.
func (m *MockStateLedger) SlotInAccessList(arg0 types.Address, arg1 types.Hash) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlotInAccessList", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// SlotInAccessList indicates an expected call of SlotInAccessList.
func (mr *MockStateLedgerMockRecorder) SlotInAccessList(arg0, arg1 any) *MockStateLedgerSlotInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlotInAccessList", reflect.TypeOf((*MockStateLedger)(nil).SlotInAccessList), arg0, arg1)
	return &MockStateLedgerSlotInAccessListCall{Call: call}
}

// MockStateLedgerSlotInAccessListCall wrap *gomock.Call
type MockStateLedgerSlotInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSlotInAccessListCall) Return(arg0, arg1 bool) *MockStateLedgerSlotInAccessListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSlotInAccessListCall) Do(f func(types.Address, types.Hash) (bool, bool)) *MockStateLedgerSlotInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSlotInAccessListCall) DoAndReturn(f func(types.Address, types.Hash) (bool, bool)) *MockStateLedgerSlotInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockStateLedger) Snapshot() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(int)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockStateLedgerMockRecorder) Snapshot() *MockStateLedgerSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockStateLedger)(nil).Snapshot))
	return &MockStateLedgerSnapshotCall{Call: call}
}

// MockStateLedgerSnapshotCall wrap *gomock.Call
type MockStateLedgerSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSnapshotCall) Return(arg0 int) *MockStateLedgerSnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSnapshotCall) Do(f func() int) *MockStateLedgerSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSnapshotCall) DoAndReturn(f func() int) *MockStateLedgerSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockStateLedger) SubBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", arg0, arg1)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockStateLedgerMockRecorder) SubBalance(arg0, arg1 any) *MockStateLedgerSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockStateLedger)(nil).SubBalance), arg0, arg1)
	return &MockStateLedgerSubBalanceCall{Call: call}
}

// MockStateLedgerSubBalanceCall wrap *gomock.Call
type MockStateLedgerSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSubBalanceCall) Return() *MockStateLedgerSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSubBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateLedgerSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSubBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateLedgerSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubRefund mocks base method.
func (m *MockStateLedger) SubRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubRefund", arg0)
}

// SubRefund indicates an expected call of SubRefund.
func (mr *MockStateLedgerMockRecorder) SubRefund(arg0 any) *MockStateLedgerSubRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubRefund", reflect.TypeOf((*MockStateLedger)(nil).SubRefund), arg0)
	return &MockStateLedgerSubRefundCall{Call: call}
}

// MockStateLedgerSubRefundCall wrap *gomock.Call
type MockStateLedgerSubRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSubRefundCall) Return() *MockStateLedgerSubRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSubRefundCall) Do(f func(uint64)) *MockStateLedgerSubRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSubRefundCall) DoAndReturn(f func(uint64)) *MockStateLedgerSubRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicide mocks base method.
func (m *MockStateLedger) Suicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicide indicates an expected call of Suicide.
func (mr *MockStateLedgerMockRecorder) Suicide(arg0 any) *MockStateLedgerSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicide", reflect.TypeOf((*MockStateLedger)(nil).Suicide), arg0)
	return &MockStateLedgerSuicideCall{Call: call}
}

// MockStateLedgerSuicideCall wrap *gomock.Call
type MockStateLedgerSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerSuicideCall) Return(arg0 bool) *MockStateLedgerSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerSuicideCall) Do(f func(*types.Address) bool) *MockStateLedgerSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerSuicideCall) DoAndReturn(f func(*types.Address) bool) *MockStateLedgerSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VerifyTrie mocks base method.
func (m *MockStateLedger) VerifyTrie(blockHeader *types.BlockHeader) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyTrie", blockHeader)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyTrie indicates an expected call of VerifyTrie.
func (mr *MockStateLedgerMockRecorder) VerifyTrie(blockHeader any) *MockStateLedgerVerifyTrieCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyTrie", reflect.TypeOf((*MockStateLedger)(nil).VerifyTrie), blockHeader)
	return &MockStateLedgerVerifyTrieCall{Call: call}
}

// MockStateLedgerVerifyTrieCall wrap *gomock.Call
type MockStateLedgerVerifyTrieCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerVerifyTrieCall) Return(arg0 bool, arg1 error) *MockStateLedgerVerifyTrieCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerVerifyTrieCall) Do(f func(*types.BlockHeader) (bool, error)) *MockStateLedgerVerifyTrieCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerVerifyTrieCall) DoAndReturn(f func(*types.BlockHeader) (bool, error)) *MockStateLedgerVerifyTrieCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Version mocks base method.
func (m *MockStateLedger) Version() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Version")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// Version indicates an expected call of Version.
func (mr *MockStateLedgerMockRecorder) Version() *MockStateLedgerVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockStateLedger)(nil).Version))
	return &MockStateLedgerVersionCall{Call: call}
}

// MockStateLedgerVersionCall wrap *gomock.Call
type MockStateLedgerVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateLedgerVersionCall) Return(arg0 uint64) *MockStateLedgerVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateLedgerVersionCall) Do(f func() uint64) *MockStateLedgerVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateLedgerVersionCall) DoAndReturn(f func() uint64) *MockStateLedgerVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateAccessor is a mock of StateAccessor interface.
type MockStateAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockStateAccessorMockRecorder
}

// MockStateAccessorMockRecorder is the mock recorder for MockStateAccessor.
type MockStateAccessorMockRecorder struct {
	mock *MockStateAccessor
}

// NewMockStateAccessor creates a new mock instance.
func NewMockStateAccessor(ctrl *gomock.Controller) *MockStateAccessor {
	mock := &MockStateAccessor{ctrl: ctrl}
	mock.recorder = &MockStateAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateAccessor) EXPECT() *MockStateAccessorMockRecorder {
	return m.recorder
}

// AddAddressToAccessList mocks base method.
func (m *MockStateAccessor) AddAddressToAccessList(arg0 types.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAddressToAccessList", arg0)
}

// AddAddressToAccessList indicates an expected call of AddAddressToAccessList.
func (mr *MockStateAccessorMockRecorder) AddAddressToAccessList(arg0 any) *MockStateAccessorAddAddressToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAddressToAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddAddressToAccessList), arg0)
	return &MockStateAccessorAddAddressToAccessListCall{Call: call}
}

// MockStateAccessorAddAddressToAccessListCall wrap *gomock.Call
type MockStateAccessorAddAddressToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddAddressToAccessListCall) Return() *MockStateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddAddressToAccessListCall) Do(f func(types.Address)) *MockStateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddAddressToAccessListCall) DoAndReturn(f func(types.Address)) *MockStateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddBalance mocks base method.
func (m *MockStateAccessor) AddBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", arg0, arg1)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockStateAccessorMockRecorder) AddBalance(arg0, arg1 any) *MockStateAccessorAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockStateAccessor)(nil).AddBalance), arg0, arg1)
	return &MockStateAccessorAddBalanceCall{Call: call}
}

// MockStateAccessorAddBalanceCall wrap *gomock.Call
type MockStateAccessorAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddBalanceCall) Return() *MockStateAccessorAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateAccessorAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateAccessorAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPreimage mocks base method.
func (m *MockStateAccessor) AddPreimage(arg0 types.Hash, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreimage", arg0, arg1)
}

// AddPreimage indicates an expected call of AddPreimage.
func (mr *MockStateAccessorMockRecorder) AddPreimage(arg0, arg1 any) *MockStateAccessorAddPreimageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreimage", reflect.TypeOf((*MockStateAccessor)(nil).AddPreimage), arg0, arg1)
	return &MockStateAccessorAddPreimageCall{Call: call}
}

// MockStateAccessorAddPreimageCall wrap *gomock.Call
type MockStateAccessorAddPreimageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddPreimageCall) Return() *MockStateAccessorAddPreimageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddPreimageCall) Do(f func(types.Hash, []byte)) *MockStateAccessorAddPreimageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddPreimageCall) DoAndReturn(f func(types.Hash, []byte)) *MockStateAccessorAddPreimageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRefund mocks base method.
func (m *MockStateAccessor) AddRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRefund", arg0)
}

// AddRefund indicates an expected call of AddRefund.
func (mr *MockStateAccessorMockRecorder) AddRefund(arg0 any) *MockStateAccessorAddRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRefund", reflect.TypeOf((*MockStateAccessor)(nil).AddRefund), arg0)
	return &MockStateAccessorAddRefundCall{Call: call}
}

// MockStateAccessorAddRefundCall wrap *gomock.Call
type MockStateAccessorAddRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddRefundCall) Return() *MockStateAccessorAddRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddRefundCall) Do(f func(uint64)) *MockStateAccessorAddRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddRefundCall) DoAndReturn(f func(uint64)) *MockStateAccessorAddRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSlotToAccessList mocks base method.
func (m *MockStateAccessor) AddSlotToAccessList(arg0 types.Address, arg1 types.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSlotToAccessList", arg0, arg1)
}

// AddSlotToAccessList indicates an expected call of AddSlotToAccessList.
func (mr *MockStateAccessorMockRecorder) AddSlotToAccessList(arg0, arg1 any) *MockStateAccessorAddSlotToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSlotToAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddSlotToAccessList), arg0, arg1)
	return &MockStateAccessorAddSlotToAccessListCall{Call: call}
}

// MockStateAccessorAddSlotToAccessListCall wrap *gomock.Call
type MockStateAccessorAddSlotToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddSlotToAccessListCall) Return() *MockStateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddSlotToAccessListCall) Do(f func(types.Address, types.Hash)) *MockStateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddSlotToAccessListCall) DoAndReturn(f func(types.Address, types.Hash)) *MockStateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddressInAccessList mocks base method.
func (m *MockStateAccessor) AddressInAccessList(arg0 types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddressInAccessList", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// AddressInAccessList indicates an expected call of AddressInAccessList.
func (mr *MockStateAccessorMockRecorder) AddressInAccessList(arg0 any) *MockStateAccessorAddressInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddressInAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddressInAccessList), arg0)
	return &MockStateAccessorAddressInAccessListCall{Call: call}
}

// MockStateAccessorAddressInAccessListCall wrap *gomock.Call
type MockStateAccessorAddressInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorAddressInAccessListCall) Return(arg0 bool) *MockStateAccessorAddressInAccessListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorAddressInAccessListCall) Do(f func(types.Address) bool) *MockStateAccessorAddressInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorAddressInAccessListCall) DoAndReturn(f func(types.Address) bool) *MockStateAccessorAddressInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Clear mocks base method.
func (m *MockStateAccessor) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateAccessorMockRecorder) Clear() *MockStateAccessorClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateAccessor)(nil).Clear))
	return &MockStateAccessorClearCall{Call: call}
}

// MockStateAccessorClearCall wrap *gomock.Call
type MockStateAccessorClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorClearCall) Return() *MockStateAccessorClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorClearCall) Do(f func()) *MockStateAccessorClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorClearCall) DoAndReturn(f func()) *MockStateAccessorClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateAccessor) Commit() (*types.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(*types.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockStateAccessorMockRecorder) Commit() *MockStateAccessorCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateAccessor)(nil).Commit))
	return &MockStateAccessorCommitCall{Call: call}
}

// MockStateAccessorCommitCall wrap *gomock.Call
type MockStateAccessorCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorCommitCall) Return(arg0 *types.Hash, arg1 error) *MockStateAccessorCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorCommitCall) Do(f func() (*types.Hash, error)) *MockStateAccessorCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorCommitCall) DoAndReturn(f func() (*types.Hash, error)) *MockStateAccessorCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Empty mocks base method.
func (m *MockStateAccessor) Empty(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty.
func (mr *MockStateAccessorMockRecorder) Empty(arg0 any) *MockStateAccessorEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockStateAccessor)(nil).Empty), arg0)
	return &MockStateAccessorEmptyCall{Call: call}
}

// MockStateAccessorEmptyCall wrap *gomock.Call
type MockStateAccessorEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorEmptyCall) Return(arg0 bool) *MockStateAccessorEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorEmptyCall) Do(f func(*types.Address) bool) *MockStateAccessorEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorEmptyCall) DoAndReturn(f func(*types.Address) bool) *MockStateAccessorEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exist mocks base method.
func (m *MockStateAccessor) Exist(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockStateAccessorMockRecorder) Exist(arg0 any) *MockStateAccessorExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStateAccessor)(nil).Exist), arg0)
	return &MockStateAccessorExistCall{Call: call}
}

// MockStateAccessorExistCall wrap *gomock.Call
type MockStateAccessorExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorExistCall) Return(arg0 bool) *MockStateAccessorExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorExistCall) Do(f func(*types.Address) bool) *MockStateAccessorExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorExistCall) DoAndReturn(f func(*types.Address) bool) *MockStateAccessorExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateAccessor) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateAccessorMockRecorder) GetAccount(arg0 any) *MockStateAccessorGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetAccount), arg0)
	return &MockStateAccessorGetAccountCall{Call: call}
}

// MockStateAccessorGetAccountCall wrap *gomock.Call
type MockStateAccessorGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetAccountCall) Return(arg0 ledger.IAccount) *MockStateAccessorGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *MockStateAccessorGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *MockStateAccessorGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateAccessor) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateAccessorMockRecorder) GetBalance(arg0 any) *MockStateAccessorGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateAccessor)(nil).GetBalance), arg0)
	return &MockStateAccessorGetBalanceCall{Call: call}
}

// MockStateAccessorGetBalanceCall wrap *gomock.Call
type MockStateAccessorGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetBalanceCall) Return(arg0 *big.Int) *MockStateAccessorGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetBalanceCall) Do(f func(*types.Address) *big.Int) *MockStateAccessorGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *MockStateAccessorGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateAccessor) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateAccessorMockRecorder) GetCode(arg0 any) *MockStateAccessorGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateAccessor)(nil).GetCode), arg0)
	return &MockStateAccessorGetCodeCall{Call: call}
}

// MockStateAccessorGetCodeCall wrap *gomock.Call
type MockStateAccessorGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetCodeCall) Return(arg0 []byte) *MockStateAccessorGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetCodeCall) Do(f func(*types.Address) []byte) *MockStateAccessorGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *MockStateAccessorGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeHash mocks base method.
func (m *MockStateAccessor) GetCodeHash(arg0 *types.Address) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeHash", arg0)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetCodeHash indicates an expected call of GetCodeHash.
func (mr *MockStateAccessorMockRecorder) GetCodeHash(arg0 any) *MockStateAccessorGetCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeHash", reflect.TypeOf((*MockStateAccessor)(nil).GetCodeHash), arg0)
	return &MockStateAccessorGetCodeHashCall{Call: call}
}

// MockStateAccessorGetCodeHashCall wrap *gomock.Call
type MockStateAccessorGetCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetCodeHashCall) Return(arg0 *types.Hash) *MockStateAccessorGetCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetCodeHashCall) Do(f func(*types.Address) *types.Hash) *MockStateAccessorGetCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetCodeHashCall) DoAndReturn(f func(*types.Address) *types.Hash) *MockStateAccessorGetCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeSize mocks base method.
func (m *MockStateAccessor) GetCodeSize(arg0 *types.Address) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeSize", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetCodeSize indicates an expected call of GetCodeSize.
func (mr *MockStateAccessorMockRecorder) GetCodeSize(arg0 any) *MockStateAccessorGetCodeSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeSize", reflect.TypeOf((*MockStateAccessor)(nil).GetCodeSize), arg0)
	return &MockStateAccessorGetCodeSizeCall{Call: call}
}

// MockStateAccessorGetCodeSizeCall wrap *gomock.Call
type MockStateAccessorGetCodeSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetCodeSizeCall) Return(arg0 int) *MockStateAccessorGetCodeSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetCodeSizeCall) Do(f func(*types.Address) int) *MockStateAccessorGetCodeSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetCodeSizeCall) DoAndReturn(f func(*types.Address) int) *MockStateAccessorGetCodeSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockStateAccessor) GetCommittedState(arg0 *types.Address, arg1 []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockStateAccessorMockRecorder) GetCommittedState(arg0, arg1 any) *MockStateAccessorGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockStateAccessor)(nil).GetCommittedState), arg0, arg1)
	return &MockStateAccessorGetCommittedStateCall{Call: call}
}

// MockStateAccessorGetCommittedStateCall wrap *gomock.Call
type MockStateAccessorGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetCommittedStateCall) Return(arg0 []byte) *MockStateAccessorGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetCommittedStateCall) Do(f func(*types.Address, []byte) []byte) *MockStateAccessorGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetCommittedStateCall) DoAndReturn(f func(*types.Address, []byte) []byte) *MockStateAccessorGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateAccessor) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateAccessorMockRecorder) GetNonce(arg0 any) *MockStateAccessorGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateAccessor)(nil).GetNonce), arg0)
	return &MockStateAccessorGetNonceCall{Call: call}
}

// MockStateAccessorGetNonceCall wrap *gomock.Call
type MockStateAccessorGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetNonceCall) Return(arg0 uint64) *MockStateAccessorGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetNonceCall) Do(f func(*types.Address) uint64) *MockStateAccessorGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *MockStateAccessorGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateAccessor) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateAccessorMockRecorder) GetOrCreateAccount(arg0 any) *MockStateAccessorGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetOrCreateAccount), arg0)
	return &MockStateAccessorGetOrCreateAccountCall{Call: call}
}

// MockStateAccessorGetOrCreateAccountCall wrap *gomock.Call
type MockStateAccessorGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *MockStateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *MockStateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *MockStateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRefund mocks base method.
func (m *MockStateAccessor) GetRefund() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRefund")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetRefund indicates an expected call of GetRefund.
func (mr *MockStateAccessorMockRecorder) GetRefund() *MockStateAccessorGetRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRefund", reflect.TypeOf((*MockStateAccessor)(nil).GetRefund))
	return &MockStateAccessorGetRefundCall{Call: call}
}

// MockStateAccessorGetRefundCall wrap *gomock.Call
type MockStateAccessorGetRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetRefundCall) Return(arg0 uint64) *MockStateAccessorGetRefundCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetRefundCall) Do(f func() uint64) *MockStateAccessorGetRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetRefundCall) DoAndReturn(f func() uint64) *MockStateAccessorGetRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateAccessor) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateAccessorMockRecorder) GetState(arg0, arg1 any) *MockStateAccessorGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateAccessor)(nil).GetState), arg0, arg1)
	return &MockStateAccessorGetStateCall{Call: call}
}

// MockStateAccessorGetStateCall wrap *gomock.Call
type MockStateAccessorGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorGetStateCall) Return(arg0 bool, arg1 []byte) *MockStateAccessorGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *MockStateAccessorGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *MockStateAccessorGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasSuicide mocks base method.
func (m *MockStateAccessor) HasSuicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSuicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSuicide indicates an expected call of HasSuicide.
func (mr *MockStateAccessorMockRecorder) HasSuicide(arg0 any) *MockStateAccessorHasSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSuicide", reflect.TypeOf((*MockStateAccessor)(nil).HasSuicide), arg0)
	return &MockStateAccessorHasSuicideCall{Call: call}
}

// MockStateAccessorHasSuicideCall wrap *gomock.Call
type MockStateAccessorHasSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorHasSuicideCall) Return(arg0 bool) *MockStateAccessorHasSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorHasSuicideCall) Do(f func(*types.Address) bool) *MockStateAccessorHasSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorHasSuicideCall) DoAndReturn(f func(*types.Address) bool) *MockStateAccessorHasSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertToSnapshot mocks base method.
func (m *MockStateAccessor) RevertToSnapshot(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RevertToSnapshot", arg0)
}

// RevertToSnapshot indicates an expected call of RevertToSnapshot.
func (mr *MockStateAccessorMockRecorder) RevertToSnapshot(arg0 any) *MockStateAccessorRevertToSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertToSnapshot", reflect.TypeOf((*MockStateAccessor)(nil).RevertToSnapshot), arg0)
	return &MockStateAccessorRevertToSnapshotCall{Call: call}
}

// MockStateAccessorRevertToSnapshotCall wrap *gomock.Call
type MockStateAccessorRevertToSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorRevertToSnapshotCall) Return() *MockStateAccessorRevertToSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorRevertToSnapshotCall) Do(f func(int)) *MockStateAccessorRevertToSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorRevertToSnapshotCall) DoAndReturn(f func(int)) *MockStateAccessorRevertToSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateAccessor) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateAccessorMockRecorder) SetBalance(arg0, arg1 any) *MockStateAccessorSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateAccessor)(nil).SetBalance), arg0, arg1)
	return &MockStateAccessorSetBalanceCall{Call: call}
}

// MockStateAccessorSetBalanceCall wrap *gomock.Call
type MockStateAccessorSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSetBalanceCall) Return() *MockStateAccessorSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSetBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateAccessorSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateAccessorSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateAccessor) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateAccessorMockRecorder) SetCode(arg0, arg1 any) *MockStateAccessorSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateAccessor)(nil).SetCode), arg0, arg1)
	return &MockStateAccessorSetCodeCall{Call: call}
}

// MockStateAccessorSetCodeCall wrap *gomock.Call
type MockStateAccessorSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSetCodeCall) Return() *MockStateAccessorSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSetCodeCall) Do(f func(*types.Address, []byte)) *MockStateAccessorSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *MockStateAccessorSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateAccessor) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateAccessorMockRecorder) SetNonce(arg0, arg1 any) *MockStateAccessorSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateAccessor)(nil).SetNonce), arg0, arg1)
	return &MockStateAccessorSetNonceCall{Call: call}
}

// MockStateAccessorSetNonceCall wrap *gomock.Call
type MockStateAccessorSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSetNonceCall) Return() *MockStateAccessorSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSetNonceCall) Do(f func(*types.Address, uint64)) *MockStateAccessorSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *MockStateAccessorSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateAccessor) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateAccessorMockRecorder) SetState(arg0, arg1, arg2 any) *MockStateAccessorSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateAccessor)(nil).SetState), arg0, arg1, arg2)
	return &MockStateAccessorSetStateCall{Call: call}
}

// MockStateAccessorSetStateCall wrap *gomock.Call
type MockStateAccessorSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSetStateCall) Return() *MockStateAccessorSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSetStateCall) Do(f func(*types.Address, []byte, []byte)) *MockStateAccessorSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *MockStateAccessorSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateAccessor) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateAccessorMockRecorder) SetTxContext(thash, txIndex any) *MockStateAccessorSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateAccessor)(nil).SetTxContext), thash, txIndex)
	return &MockStateAccessorSetTxContextCall{Call: call}
}

// MockStateAccessorSetTxContextCall wrap *gomock.Call
type MockStateAccessorSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSetTxContextCall) Return() *MockStateAccessorSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSetTxContextCall) Do(f func(*types.Hash, int)) *MockStateAccessorSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *MockStateAccessorSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlotInAccessList mocks base method.
func (m *MockStateAccessor) SlotInAccessList(arg0 types.Address, arg1 types.Hash) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlotInAccessList", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// SlotInAccessList indicates an expected call of SlotInAccessList.
func (mr *MockStateAccessorMockRecorder) SlotInAccessList(arg0, arg1 any) *MockStateAccessorSlotInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlotInAccessList", reflect.TypeOf((*MockStateAccessor)(nil).SlotInAccessList), arg0, arg1)
	return &MockStateAccessorSlotInAccessListCall{Call: call}
}

// MockStateAccessorSlotInAccessListCall wrap *gomock.Call
type MockStateAccessorSlotInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSlotInAccessListCall) Return(arg0, arg1 bool) *MockStateAccessorSlotInAccessListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSlotInAccessListCall) Do(f func(types.Address, types.Hash) (bool, bool)) *MockStateAccessorSlotInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSlotInAccessListCall) DoAndReturn(f func(types.Address, types.Hash) (bool, bool)) *MockStateAccessorSlotInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockStateAccessor) Snapshot() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(int)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockStateAccessorMockRecorder) Snapshot() *MockStateAccessorSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockStateAccessor)(nil).Snapshot))
	return &MockStateAccessorSnapshotCall{Call: call}
}

// MockStateAccessorSnapshotCall wrap *gomock.Call
type MockStateAccessorSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSnapshotCall) Return(arg0 int) *MockStateAccessorSnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSnapshotCall) Do(f func() int) *MockStateAccessorSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSnapshotCall) DoAndReturn(f func() int) *MockStateAccessorSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockStateAccessor) SubBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", arg0, arg1)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockStateAccessorMockRecorder) SubBalance(arg0, arg1 any) *MockStateAccessorSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockStateAccessor)(nil).SubBalance), arg0, arg1)
	return &MockStateAccessorSubBalanceCall{Call: call}
}

// MockStateAccessorSubBalanceCall wrap *gomock.Call
type MockStateAccessorSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSubBalanceCall) Return() *MockStateAccessorSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSubBalanceCall) Do(f func(*types.Address, *big.Int)) *MockStateAccessorSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSubBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *MockStateAccessorSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubRefund mocks base method.
func (m *MockStateAccessor) SubRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubRefund", arg0)
}

// SubRefund indicates an expected call of SubRefund.
func (mr *MockStateAccessorMockRecorder) SubRefund(arg0 any) *MockStateAccessorSubRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubRefund", reflect.TypeOf((*MockStateAccessor)(nil).SubRefund), arg0)
	return &MockStateAccessorSubRefundCall{Call: call}
}

// MockStateAccessorSubRefundCall wrap *gomock.Call
type MockStateAccessorSubRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSubRefundCall) Return() *MockStateAccessorSubRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSubRefundCall) Do(f func(uint64)) *MockStateAccessorSubRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSubRefundCall) DoAndReturn(f func(uint64)) *MockStateAccessorSubRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicide mocks base method.
func (m *MockStateAccessor) Suicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicide indicates an expected call of Suicide.
func (mr *MockStateAccessorMockRecorder) Suicide(arg0 any) *MockStateAccessorSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicide", reflect.TypeOf((*MockStateAccessor)(nil).Suicide), arg0)
	return &MockStateAccessorSuicideCall{Call: call}
}

// MockStateAccessorSuicideCall wrap *gomock.Call
type MockStateAccessorSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockStateAccessorSuicideCall) Return(arg0 bool) *MockStateAccessorSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockStateAccessorSuicideCall) Do(f func(*types.Address) bool) *MockStateAccessorSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockStateAccessorSuicideCall) DoAndReturn(f func(*types.Address) bool) *MockStateAccessorSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockIAccount is a mock of IAccount interface.
type MockIAccount struct {
	ctrl     *gomock.Controller
	recorder *MockIAccountMockRecorder
}

// MockIAccountMockRecorder is the mock recorder for MockIAccount.
type MockIAccountMockRecorder struct {
	mock *MockIAccount
}

// NewMockIAccount creates a new mock instance.
func NewMockIAccount(ctrl *gomock.Controller) *MockIAccount {
	mock := &MockIAccount{ctrl: ctrl}
	mock.recorder = &MockIAccountMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAccount) EXPECT() *MockIAccountMockRecorder {
	return m.recorder
}

// AddBalance mocks base method.
func (m *MockIAccount) AddBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", amount)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockIAccountMockRecorder) AddBalance(amount any) *MockIAccountAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockIAccount)(nil).AddBalance), amount)
	return &MockIAccountAddBalanceCall{Call: call}
}

// MockIAccountAddBalanceCall wrap *gomock.Call
type MockIAccountAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountAddBalanceCall) Return() *MockIAccountAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountAddBalanceCall) Do(f func(*big.Int)) *MockIAccountAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountAddBalanceCall) DoAndReturn(f func(*big.Int)) *MockIAccountAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Code mocks base method.
func (m *MockIAccount) Code() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Code")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Code indicates an expected call of Code.
func (mr *MockIAccountMockRecorder) Code() *MockIAccountCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockIAccount)(nil).Code))
	return &MockIAccountCodeCall{Call: call}
}

// MockIAccountCodeCall wrap *gomock.Call
type MockIAccountCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountCodeCall) Return(arg0 []byte) *MockIAccountCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountCodeCall) Do(f func() []byte) *MockIAccountCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountCodeCall) DoAndReturn(f func() []byte) *MockIAccountCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CodeHash mocks base method.
func (m *MockIAccount) CodeHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CodeHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// CodeHash indicates an expected call of CodeHash.
func (mr *MockIAccountMockRecorder) CodeHash() *MockIAccountCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CodeHash", reflect.TypeOf((*MockIAccount)(nil).CodeHash))
	return &MockIAccountCodeHashCall{Call: call}
}

// MockIAccountCodeHashCall wrap *gomock.Call
type MockIAccountCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountCodeHashCall) Return(arg0 []byte) *MockIAccountCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountCodeHashCall) Do(f func() []byte) *MockIAccountCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountCodeHashCall) DoAndReturn(f func() []byte) *MockIAccountCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockIAccount) Finalise() [][]byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Finalise")
	ret0, _ := ret[0].([][]byte)
	return ret0
}

// Finalise indicates an expected call of Finalise.
func (mr *MockIAccountMockRecorder) Finalise() *MockIAccountFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockIAccount)(nil).Finalise))
	return &MockIAccountFinaliseCall{Call: call}
}

// MockIAccountFinaliseCall wrap *gomock.Call
type MockIAccountFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountFinaliseCall) Return(arg0 [][]byte) *MockIAccountFinaliseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountFinaliseCall) Do(f func() [][]byte) *MockIAccountFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountFinaliseCall) DoAndReturn(f func() [][]byte) *MockIAccountFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAddress mocks base method.
func (m *MockIAccount) GetAddress() *types.Address {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddress")
	ret0, _ := ret[0].(*types.Address)
	return ret0
}

// GetAddress indicates an expected call of GetAddress.
func (mr *MockIAccountMockRecorder) GetAddress() *MockIAccountGetAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddress", reflect.TypeOf((*MockIAccount)(nil).GetAddress))
	return &MockIAccountGetAddressCall{Call: call}
}

// MockIAccountGetAddressCall wrap *gomock.Call
type MockIAccountGetAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetAddressCall) Return(arg0 *types.Address) *MockIAccountGetAddressCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetAddressCall) Do(f func() *types.Address) *MockIAccountGetAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetAddressCall) DoAndReturn(f func() *types.Address) *MockIAccountGetAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockIAccount) GetBalance() *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance")
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockIAccountMockRecorder) GetBalance() *MockIAccountGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockIAccount)(nil).GetBalance))
	return &MockIAccountGetBalanceCall{Call: call}
}

// MockIAccountGetBalanceCall wrap *gomock.Call
type MockIAccountGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetBalanceCall) Return(arg0 *big.Int) *MockIAccountGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetBalanceCall) Do(f func() *big.Int) *MockIAccountGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetBalanceCall) DoAndReturn(f func() *big.Int) *MockIAccountGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockIAccount) GetCommittedState(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockIAccountMockRecorder) GetCommittedState(key any) *MockIAccountGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockIAccount)(nil).GetCommittedState), key)
	return &MockIAccountGetCommittedStateCall{Call: call}
}

// MockIAccountGetCommittedStateCall wrap *gomock.Call
type MockIAccountGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetCommittedStateCall) Return(arg0 []byte) *MockIAccountGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetCommittedStateCall) Do(f func([]byte) []byte) *MockIAccountGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetCommittedStateCall) DoAndReturn(f func([]byte) []byte) *MockIAccountGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockIAccount) GetNonce() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockIAccountMockRecorder) GetNonce() *MockIAccountGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockIAccount)(nil).GetNonce))
	return &MockIAccountGetNonceCall{Call: call}
}

// MockIAccountGetNonceCall wrap *gomock.Call
type MockIAccountGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetNonceCall) Return(arg0 uint64) *MockIAccountGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetNonceCall) Do(f func() uint64) *MockIAccountGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetNonceCall) DoAndReturn(f func() uint64) *MockIAccountGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockIAccount) GetState(key []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockIAccountMockRecorder) GetState(key any) *MockIAccountGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockIAccount)(nil).GetState), key)
	return &MockIAccountGetStateCall{Call: call}
}

// MockIAccountGetStateCall wrap *gomock.Call
type MockIAccountGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetStateCall) Return(arg0 bool, arg1 []byte) *MockIAccountGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetStateCall) Do(f func([]byte) (bool, []byte)) *MockIAccountGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetStateCall) DoAndReturn(f func([]byte) (bool, []byte)) *MockIAccountGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStorageRoot mocks base method.
func (m *MockIAccount) GetStorageRoot() common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageRoot")
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetStorageRoot indicates an expected call of GetStorageRoot.
func (mr *MockIAccountMockRecorder) GetStorageRoot() *MockIAccountGetStorageRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageRoot", reflect.TypeOf((*MockIAccount)(nil).GetStorageRoot))
	return &MockIAccountGetStorageRootCall{Call: call}
}

// MockIAccountGetStorageRootCall wrap *gomock.Call
type MockIAccountGetStorageRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetStorageRootCall) Return(arg0 common.Hash) *MockIAccountGetStorageRootCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetStorageRootCall) Do(f func() common.Hash) *MockIAccountGetStorageRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetStorageRootCall) DoAndReturn(f func() common.Hash) *MockIAccountGetStorageRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStorageRootHash mocks base method.
func (m *MockIAccount) GetStorageRootHash() common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageRootHash")
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetStorageRootHash indicates an expected call of GetStorageRootHash.
func (mr *MockIAccountMockRecorder) GetStorageRootHash() *MockIAccountGetStorageRootHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageRootHash", reflect.TypeOf((*MockIAccount)(nil).GetStorageRootHash))
	return &MockIAccountGetStorageRootHashCall{Call: call}
}

// MockIAccountGetStorageRootHashCall wrap *gomock.Call
type MockIAccountGetStorageRootHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountGetStorageRootHashCall) Return(arg0 common.Hash) *MockIAccountGetStorageRootHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountGetStorageRootHashCall) Do(f func() common.Hash) *MockIAccountGetStorageRootHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountGetStorageRootHashCall) DoAndReturn(f func() common.Hash) *MockIAccountGetStorageRootHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsEmpty mocks base method.
func (m *MockIAccount) IsEmpty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockIAccountMockRecorder) IsEmpty() *MockIAccountIsEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockIAccount)(nil).IsEmpty))
	return &MockIAccountIsEmptyCall{Call: call}
}

// MockIAccountIsEmptyCall wrap *gomock.Call
type MockIAccountIsEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountIsEmptyCall) Return(arg0 bool) *MockIAccountIsEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountIsEmptyCall) Do(f func() bool) *MockIAccountIsEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountIsEmptyCall) DoAndReturn(f func() bool) *MockIAccountIsEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockIAccount) SetBalance(balance *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", balance)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockIAccountMockRecorder) SetBalance(balance any) *MockIAccountSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockIAccount)(nil).SetBalance), balance)
	return &MockIAccountSetBalanceCall{Call: call}
}

// MockIAccountSetBalanceCall wrap *gomock.Call
type MockIAccountSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetBalanceCall) Return() *MockIAccountSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetBalanceCall) Do(f func(*big.Int)) *MockIAccountSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetBalanceCall) DoAndReturn(f func(*big.Int)) *MockIAccountSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCodeAndHash mocks base method.
func (m *MockIAccount) SetCodeAndHash(code []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCodeAndHash", code)
}

// SetCodeAndHash indicates an expected call of SetCodeAndHash.
func (mr *MockIAccountMockRecorder) SetCodeAndHash(code any) *MockIAccountSetCodeAndHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCodeAndHash", reflect.TypeOf((*MockIAccount)(nil).SetCodeAndHash), code)
	return &MockIAccountSetCodeAndHashCall{Call: call}
}

// MockIAccountSetCodeAndHashCall wrap *gomock.Call
type MockIAccountSetCodeAndHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetCodeAndHashCall) Return() *MockIAccountSetCodeAndHashCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetCodeAndHashCall) Do(f func([]byte)) *MockIAccountSetCodeAndHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetCodeAndHashCall) DoAndReturn(f func([]byte)) *MockIAccountSetCodeAndHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEnableExpensiveMetric mocks base method.
func (m *MockIAccount) SetEnableExpensiveMetric(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEnableExpensiveMetric", arg0)
}

// SetEnableExpensiveMetric indicates an expected call of SetEnableExpensiveMetric.
func (mr *MockIAccountMockRecorder) SetEnableExpensiveMetric(arg0 any) *MockIAccountSetEnableExpensiveMetricCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEnableExpensiveMetric", reflect.TypeOf((*MockIAccount)(nil).SetEnableExpensiveMetric), arg0)
	return &MockIAccountSetEnableExpensiveMetricCall{Call: call}
}

// MockIAccountSetEnableExpensiveMetricCall wrap *gomock.Call
type MockIAccountSetEnableExpensiveMetricCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetEnableExpensiveMetricCall) Return() *MockIAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetEnableExpensiveMetricCall) Do(f func(bool)) *MockIAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetEnableExpensiveMetricCall) DoAndReturn(f func(bool)) *MockIAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockIAccount) SetNonce(nonce uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", nonce)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockIAccountMockRecorder) SetNonce(nonce any) *MockIAccountSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockIAccount)(nil).SetNonce), nonce)
	return &MockIAccountSetNonceCall{Call: call}
}

// MockIAccountSetNonceCall wrap *gomock.Call
type MockIAccountSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetNonceCall) Return() *MockIAccountSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetNonceCall) Do(f func(uint64)) *MockIAccountSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetNonceCall) DoAndReturn(f func(uint64)) *MockIAccountSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockIAccount) SetState(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", key, value)
}

// SetState indicates an expected call of SetState.
func (mr *MockIAccountMockRecorder) SetState(key, value any) *MockIAccountSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockIAccount)(nil).SetState), key, value)
	return &MockIAccountSetStateCall{Call: call}
}

// MockIAccountSetStateCall wrap *gomock.Call
type MockIAccountSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetStateCall) Return() *MockIAccountSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetStateCall) Do(f func([]byte, []byte)) *MockIAccountSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetStateCall) DoAndReturn(f func([]byte, []byte)) *MockIAccountSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSuicided mocks base method.
func (m *MockIAccount) SetSuicided(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetSuicided", arg0)
}

// SetSuicided indicates an expected call of SetSuicided.
func (mr *MockIAccountMockRecorder) SetSuicided(arg0 any) *MockIAccountSetSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSuicided", reflect.TypeOf((*MockIAccount)(nil).SetSuicided), arg0)
	return &MockIAccountSetSuicidedCall{Call: call}
}

// MockIAccountSetSuicidedCall wrap *gomock.Call
type MockIAccountSetSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSetSuicidedCall) Return() *MockIAccountSetSuicidedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSetSuicidedCall) Do(f func(bool)) *MockIAccountSetSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSetSuicidedCall) DoAndReturn(f func(bool)) *MockIAccountSetSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// String mocks base method.
func (m *MockIAccount) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockIAccountMockRecorder) String() *MockIAccountStringCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockIAccount)(nil).String))
	return &MockIAccountStringCall{Call: call}
}

// MockIAccountStringCall wrap *gomock.Call
type MockIAccountStringCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountStringCall) Return(arg0 string) *MockIAccountStringCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountStringCall) Do(f func() string) *MockIAccountStringCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountStringCall) DoAndReturn(f func() string) *MockIAccountStringCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockIAccount) SubBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", amount)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockIAccountMockRecorder) SubBalance(amount any) *MockIAccountSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockIAccount)(nil).SubBalance), amount)
	return &MockIAccountSubBalanceCall{Call: call}
}

// MockIAccountSubBalanceCall wrap *gomock.Call
type MockIAccountSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSubBalanceCall) Return() *MockIAccountSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSubBalanceCall) Do(f func(*big.Int)) *MockIAccountSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSubBalanceCall) DoAndReturn(f func(*big.Int)) *MockIAccountSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicided mocks base method.
func (m *MockIAccount) Suicided() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicided")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicided indicates an expected call of Suicided.
func (mr *MockIAccountMockRecorder) Suicided() *MockIAccountSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicided", reflect.TypeOf((*MockIAccount)(nil).Suicided))
	return &MockIAccountSuicidedCall{Call: call}
}

// MockIAccountSuicidedCall wrap *gomock.Call
type MockIAccountSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIAccountSuicidedCall) Return(arg0 bool) *MockIAccountSuicidedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIAccountSuicidedCall) Do(f func() bool) *MockIAccountSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIAccountSuicidedCall) DoAndReturn(f func() bool) *MockIAccountSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
