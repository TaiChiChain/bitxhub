// Code generated by MockGen. DO NOT EDIT.
// Source: ledger.go
//
// Generated by this command:
//
//	mockgen -destination mock_ledger/mock_ledger.go -package mock_ledger -source ledger.go -typed
//

// Package mock_ledger is a generated GoMock package.
package mock_ledger

import (
	big "math/big"
	reflect "reflect"

	jmt "github.com/axiomesh/axiom-kit/jmt"
	storage "github.com/axiomesh/axiom-kit/storage"
	types "github.com/axiomesh/axiom-kit/types"
	ledger "github.com/axiomesh/axiom-ledger/internal/ledger"
	common "github.com/ethereum/go-ethereum/common"
	gomock "go.uber.org/mock/gomock"
)

// MockChainLedger is a mock of ChainLedger interface.
type MockChainLedger struct {
	ctrl     *gomock.Controller
	recorder *MockChainLedgerMockRecorder
}

// MockChainLedgerMockRecorder is the mock recorder for MockChainLedger.
type MockChainLedgerMockRecorder struct {
	mock *MockChainLedger
}

// NewMockChainLedger creates a new mock instance.
func NewMockChainLedger(ctrl *gomock.Controller) *MockChainLedger {
	mock := &MockChainLedger{ctrl: ctrl}
	mock.recorder = &MockChainLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChainLedger) EXPECT() *MockChainLedgerMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockChainLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockChainLedgerMockRecorder) Close() *ChainLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockChainLedger)(nil).Close))
	return &ChainLedgerCloseCall{Call: call}
}

// ChainLedgerCloseCall wrap *gomock.Call
type ChainLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerCloseCall) Return() *ChainLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerCloseCall) Do(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerCloseCall) DoAndReturn(f func()) *ChainLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CloseBlockfile mocks base method.
func (m *MockChainLedger) CloseBlockfile() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseBlockfile")
}

// CloseBlockfile indicates an expected call of CloseBlockfile.
func (mr *MockChainLedgerMockRecorder) CloseBlockfile() *ChainLedgerCloseBlockfileCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseBlockfile", reflect.TypeOf((*MockChainLedger)(nil).CloseBlockfile))
	return &ChainLedgerCloseBlockfileCall{Call: call}
}

// ChainLedgerCloseBlockfileCall wrap *gomock.Call
type ChainLedgerCloseBlockfileCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerCloseBlockfileCall) Return() *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerCloseBlockfileCall) Do(f func()) *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerCloseBlockfileCall) DoAndReturn(f func()) *ChainLedgerCloseBlockfileCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlock mocks base method.
func (m *MockChainLedger) GetBlock(height uint64) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlock", height)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockChainLedgerMockRecorder) GetBlock(height any) *ChainLedgerGetBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockChainLedger)(nil).GetBlock), height)
	return &ChainLedgerGetBlockCall{Call: call}
}

// ChainLedgerGetBlockCall wrap *gomock.Call
type ChainLedgerGetBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockCall) Do(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockCall) DoAndReturn(f func(uint64) (*types.Block, error)) *ChainLedgerGetBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockByHash mocks base method.
func (m *MockChainLedger) GetBlockByHash(hash *types.Hash) (*types.Block, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockByHash", hash)
	ret0, _ := ret[0].(*types.Block)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockByHash indicates an expected call of GetBlockByHash.
func (mr *MockChainLedgerMockRecorder) GetBlockByHash(hash any) *ChainLedgerGetBlockByHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockByHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockByHash), hash)
	return &ChainLedgerGetBlockByHashCall{Call: call}
}

// ChainLedgerGetBlockByHashCall wrap *gomock.Call
type ChainLedgerGetBlockByHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockByHashCall) Return(arg0 *types.Block, arg1 error) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockByHashCall) Do(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockByHashCall) DoAndReturn(f func(*types.Hash) (*types.Block, error)) *ChainLedgerGetBlockByHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockHash mocks base method.
func (m *MockChainLedger) GetBlockHash(height uint64) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockHash", height)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetBlockHash indicates an expected call of GetBlockHash.
func (mr *MockChainLedgerMockRecorder) GetBlockHash(height any) *ChainLedgerGetBlockHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockHash", reflect.TypeOf((*MockChainLedger)(nil).GetBlockHash), height)
	return &ChainLedgerGetBlockHashCall{Call: call}
}

// ChainLedgerGetBlockHashCall wrap *gomock.Call
type ChainLedgerGetBlockHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockHashCall) Return(arg0 *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockHashCall) Do(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockHashCall) DoAndReturn(f func(uint64) *types.Hash) *ChainLedgerGetBlockHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBlockSign mocks base method.
func (m *MockChainLedger) GetBlockSign(height uint64) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBlockSign", height)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockSign indicates an expected call of GetBlockSign.
func (mr *MockChainLedgerMockRecorder) GetBlockSign(height any) *ChainLedgerGetBlockSignCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockSign", reflect.TypeOf((*MockChainLedger)(nil).GetBlockSign), height)
	return &ChainLedgerGetBlockSignCall{Call: call}
}

// ChainLedgerGetBlockSignCall wrap *gomock.Call
type ChainLedgerGetBlockSignCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetBlockSignCall) Return(arg0 []byte, arg1 error) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetBlockSignCall) Do(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetBlockSignCall) DoAndReturn(f func(uint64) ([]byte, error)) *ChainLedgerGetBlockSignCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainMeta mocks base method.
func (m *MockChainLedger) GetChainMeta() *types.ChainMeta {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	return ret0
}

// GetChainMeta indicates an expected call of GetChainMeta.
func (mr *MockChainLedgerMockRecorder) GetChainMeta() *ChainLedgerGetChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainMeta", reflect.TypeOf((*MockChainLedger)(nil).GetChainMeta))
	return &ChainLedgerGetChainMetaCall{Call: call}
}

// ChainLedgerGetChainMetaCall wrap *gomock.Call
type ChainLedgerGetChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetChainMetaCall) Return(arg0 *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetChainMetaCall) Do(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetChainMetaCall) DoAndReturn(f func() *types.ChainMeta) *ChainLedgerGetChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReceipt mocks base method.
func (m *MockChainLedger) GetReceipt(hash *types.Hash) (*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReceipt", hash)
	ret0, _ := ret[0].(*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReceipt indicates an expected call of GetReceipt.
func (mr *MockChainLedgerMockRecorder) GetReceipt(hash any) *ChainLedgerGetReceiptCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceipt", reflect.TypeOf((*MockChainLedger)(nil).GetReceipt), hash)
	return &ChainLedgerGetReceiptCall{Call: call}
}

// ChainLedgerGetReceiptCall wrap *gomock.Call
type ChainLedgerGetReceiptCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetReceiptCall) Return(arg0 *types.Receipt, arg1 error) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetReceiptCall) Do(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetReceiptCall) DoAndReturn(f func(*types.Hash) (*types.Receipt, error)) *ChainLedgerGetReceiptCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetReceiptsByHeight mocks base method.
func (m *MockChainLedger) GetReceiptsByHeight(height uint64) ([]*types.Receipt, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetReceiptsByHeight", height)
	ret0, _ := ret[0].([]*types.Receipt)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetReceiptsByHeight indicates an expected call of GetReceiptsByHeight.
func (mr *MockChainLedgerMockRecorder) GetReceiptsByHeight(height any) *ChainLedgerGetReceiptsByHeightCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReceiptsByHeight", reflect.TypeOf((*MockChainLedger)(nil).GetReceiptsByHeight), height)
	return &ChainLedgerGetReceiptsByHeightCall{Call: call}
}

// ChainLedgerGetReceiptsByHeightCall wrap *gomock.Call
type ChainLedgerGetReceiptsByHeightCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetReceiptsByHeightCall) Return(arg0 []*types.Receipt, arg1 error) *ChainLedgerGetReceiptsByHeightCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetReceiptsByHeightCall) Do(f func(uint64) ([]*types.Receipt, error)) *ChainLedgerGetReceiptsByHeightCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetReceiptsByHeightCall) DoAndReturn(f func(uint64) ([]*types.Receipt, error)) *ChainLedgerGetReceiptsByHeightCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *MockChainLedger) GetTransaction(hash *types.Hash) (*types.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", hash)
	ret0, _ := ret[0].(*types.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *MockChainLedgerMockRecorder) GetTransaction(hash any) *ChainLedgerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockChainLedger)(nil).GetTransaction), hash)
	return &ChainLedgerGetTransactionCall{Call: call}
}

// ChainLedgerGetTransactionCall wrap *gomock.Call
type ChainLedgerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCall) Return(arg0 *types.Transaction, arg1 error) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCall) Do(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCall) DoAndReturn(f func(*types.Hash) (*types.Transaction, error)) *ChainLedgerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionCount mocks base method.
func (m *MockChainLedger) GetTransactionCount(height uint64) (uint64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionCount", height)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionCount indicates an expected call of GetTransactionCount.
func (mr *MockChainLedgerMockRecorder) GetTransactionCount(height any) *ChainLedgerGetTransactionCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionCount", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionCount), height)
	return &ChainLedgerGetTransactionCountCall{Call: call}
}

// ChainLedgerGetTransactionCountCall wrap *gomock.Call
type ChainLedgerGetTransactionCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionCountCall) Return(arg0 uint64, arg1 error) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionCountCall) Do(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionCountCall) DoAndReturn(f func(uint64) (uint64, error)) *ChainLedgerGetTransactionCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionMeta mocks base method.
func (m *MockChainLedger) GetTransactionMeta(hash *types.Hash) (*types.TransactionMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionMeta", hash)
	ret0, _ := ret[0].(*types.TransactionMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionMeta indicates an expected call of GetTransactionMeta.
func (mr *MockChainLedgerMockRecorder) GetTransactionMeta(hash any) *ChainLedgerGetTransactionMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionMeta", reflect.TypeOf((*MockChainLedger)(nil).GetTransactionMeta), hash)
	return &ChainLedgerGetTransactionMetaCall{Call: call}
}

// ChainLedgerGetTransactionMetaCall wrap *gomock.Call
type ChainLedgerGetTransactionMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerGetTransactionMetaCall) Return(arg0 *types.TransactionMeta, arg1 error) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerGetTransactionMetaCall) Do(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerGetTransactionMetaCall) DoAndReturn(f func(*types.Hash) (*types.TransactionMeta, error)) *ChainLedgerGetTransactionMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoadChainMeta mocks base method.
func (m *MockChainLedger) LoadChainMeta() (*types.ChainMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadChainMeta")
	ret0, _ := ret[0].(*types.ChainMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadChainMeta indicates an expected call of LoadChainMeta.
func (mr *MockChainLedgerMockRecorder) LoadChainMeta() *ChainLedgerLoadChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadChainMeta", reflect.TypeOf((*MockChainLedger)(nil).LoadChainMeta))
	return &ChainLedgerLoadChainMetaCall{Call: call}
}

// ChainLedgerLoadChainMetaCall wrap *gomock.Call
type ChainLedgerLoadChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerLoadChainMetaCall) Return(arg0 *types.ChainMeta, arg1 error) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerLoadChainMetaCall) Do(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerLoadChainMetaCall) DoAndReturn(f func() (*types.ChainMeta, error)) *ChainLedgerLoadChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PersistExecutionResult mocks base method.
func (m *MockChainLedger) PersistExecutionResult(block *types.Block, receipts []*types.Receipt) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PersistExecutionResult", block, receipts)
	ret0, _ := ret[0].(error)
	return ret0
}

// PersistExecutionResult indicates an expected call of PersistExecutionResult.
func (mr *MockChainLedgerMockRecorder) PersistExecutionResult(block, receipts any) *ChainLedgerPersistExecutionResultCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistExecutionResult", reflect.TypeOf((*MockChainLedger)(nil).PersistExecutionResult), block, receipts)
	return &ChainLedgerPersistExecutionResultCall{Call: call}
}

// ChainLedgerPersistExecutionResultCall wrap *gomock.Call
type ChainLedgerPersistExecutionResultCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerPersistExecutionResultCall) Return(arg0 error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerPersistExecutionResultCall) Do(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerPersistExecutionResultCall) DoAndReturn(f func(*types.Block, []*types.Receipt) error) *ChainLedgerPersistExecutionResultCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackBlockChain mocks base method.
func (m *MockChainLedger) RollbackBlockChain(height uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackBlockChain", height)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackBlockChain indicates an expected call of RollbackBlockChain.
func (mr *MockChainLedgerMockRecorder) RollbackBlockChain(height any) *ChainLedgerRollbackBlockChainCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackBlockChain", reflect.TypeOf((*MockChainLedger)(nil).RollbackBlockChain), height)
	return &ChainLedgerRollbackBlockChainCall{Call: call}
}

// ChainLedgerRollbackBlockChainCall wrap *gomock.Call
type ChainLedgerRollbackBlockChainCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerRollbackBlockChainCall) Return(arg0 error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerRollbackBlockChainCall) Do(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerRollbackBlockChainCall) DoAndReturn(f func(uint64) error) *ChainLedgerRollbackBlockChainCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainMeta mocks base method.
func (m *MockChainLedger) UpdateChainMeta(arg0 *types.ChainMeta) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainMeta", arg0)
}

// UpdateChainMeta indicates an expected call of UpdateChainMeta.
func (mr *MockChainLedgerMockRecorder) UpdateChainMeta(arg0 any) *ChainLedgerUpdateChainMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainMeta", reflect.TypeOf((*MockChainLedger)(nil).UpdateChainMeta), arg0)
	return &ChainLedgerUpdateChainMetaCall{Call: call}
}

// ChainLedgerUpdateChainMetaCall wrap *gomock.Call
type ChainLedgerUpdateChainMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *ChainLedgerUpdateChainMetaCall) Return() *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *ChainLedgerUpdateChainMetaCall) Do(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *ChainLedgerUpdateChainMetaCall) DoAndReturn(f func(*types.ChainMeta)) *ChainLedgerUpdateChainMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateLedger is a mock of StateLedger interface.
type MockStateLedger struct {
	ctrl     *gomock.Controller
	recorder *MockStateLedgerMockRecorder
}

// MockStateLedgerMockRecorder is the mock recorder for MockStateLedger.
type MockStateLedgerMockRecorder struct {
	mock *MockStateLedger
}

// NewMockStateLedger creates a new mock instance.
func NewMockStateLedger(ctrl *gomock.Controller) *MockStateLedger {
	mock := &MockStateLedger{ctrl: ctrl}
	mock.recorder = &MockStateLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateLedger) EXPECT() *MockStateLedgerMockRecorder {
	return m.recorder
}

// AddAddressToAccessList mocks base method.
func (m *MockStateLedger) AddAddressToAccessList(arg0 types.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAddressToAccessList", arg0)
}

// AddAddressToAccessList indicates an expected call of AddAddressToAccessList.
func (mr *MockStateLedgerMockRecorder) AddAddressToAccessList(arg0 any) *StateLedgerAddAddressToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAddressToAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddAddressToAccessList), arg0)
	return &StateLedgerAddAddressToAccessListCall{Call: call}
}

// StateLedgerAddAddressToAccessListCall wrap *gomock.Call
type StateLedgerAddAddressToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddAddressToAccessListCall) Return() *StateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddAddressToAccessListCall) Do(f func(types.Address)) *StateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddAddressToAccessListCall) DoAndReturn(f func(types.Address)) *StateLedgerAddAddressToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddBalance mocks base method.
func (m *MockStateLedger) AddBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", arg0, arg1)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockStateLedgerMockRecorder) AddBalance(arg0, arg1 any) *StateLedgerAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockStateLedger)(nil).AddBalance), arg0, arg1)
	return &StateLedgerAddBalanceCall{Call: call}
}

// StateLedgerAddBalanceCall wrap *gomock.Call
type StateLedgerAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddBalanceCall) Return() *StateLedgerAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddBalanceCall) Do(f func(*types.Address, *big.Int)) *StateLedgerAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateLedgerAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddLog mocks base method.
func (m *MockStateLedger) AddLog(log *types.EvmLog) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddLog", log)
}

// AddLog indicates an expected call of AddLog.
func (mr *MockStateLedgerMockRecorder) AddLog(log any) *StateLedgerAddLogCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLog", reflect.TypeOf((*MockStateLedger)(nil).AddLog), log)
	return &StateLedgerAddLogCall{Call: call}
}

// StateLedgerAddLogCall wrap *gomock.Call
type StateLedgerAddLogCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddLogCall) Return() *StateLedgerAddLogCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddLogCall) Do(f func(*types.EvmLog)) *StateLedgerAddLogCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddLogCall) DoAndReturn(f func(*types.EvmLog)) *StateLedgerAddLogCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPreimage mocks base method.
func (m *MockStateLedger) AddPreimage(arg0 types.Hash, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreimage", arg0, arg1)
}

// AddPreimage indicates an expected call of AddPreimage.
func (mr *MockStateLedgerMockRecorder) AddPreimage(arg0, arg1 any) *StateLedgerAddPreimageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreimage", reflect.TypeOf((*MockStateLedger)(nil).AddPreimage), arg0, arg1)
	return &StateLedgerAddPreimageCall{Call: call}
}

// StateLedgerAddPreimageCall wrap *gomock.Call
type StateLedgerAddPreimageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddPreimageCall) Return() *StateLedgerAddPreimageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddPreimageCall) Do(f func(types.Hash, []byte)) *StateLedgerAddPreimageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddPreimageCall) DoAndReturn(f func(types.Hash, []byte)) *StateLedgerAddPreimageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRefund mocks base method.
func (m *MockStateLedger) AddRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRefund", arg0)
}

// AddRefund indicates an expected call of AddRefund.
func (mr *MockStateLedgerMockRecorder) AddRefund(arg0 any) *StateLedgerAddRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRefund", reflect.TypeOf((*MockStateLedger)(nil).AddRefund), arg0)
	return &StateLedgerAddRefundCall{Call: call}
}

// StateLedgerAddRefundCall wrap *gomock.Call
type StateLedgerAddRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddRefundCall) Return() *StateLedgerAddRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddRefundCall) Do(f func(uint64)) *StateLedgerAddRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddRefundCall) DoAndReturn(f func(uint64)) *StateLedgerAddRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSlotToAccessList mocks base method.
func (m *MockStateLedger) AddSlotToAccessList(arg0 types.Address, arg1 types.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSlotToAccessList", arg0, arg1)
}

// AddSlotToAccessList indicates an expected call of AddSlotToAccessList.
func (mr *MockStateLedgerMockRecorder) AddSlotToAccessList(arg0, arg1 any) *StateLedgerAddSlotToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSlotToAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddSlotToAccessList), arg0, arg1)
	return &StateLedgerAddSlotToAccessListCall{Call: call}
}

// StateLedgerAddSlotToAccessListCall wrap *gomock.Call
type StateLedgerAddSlotToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddSlotToAccessListCall) Return() *StateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddSlotToAccessListCall) Do(f func(types.Address, types.Hash)) *StateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddSlotToAccessListCall) DoAndReturn(f func(types.Address, types.Hash)) *StateLedgerAddSlotToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddressInAccessList mocks base method.
func (m *MockStateLedger) AddressInAccessList(arg0 types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddressInAccessList", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// AddressInAccessList indicates an expected call of AddressInAccessList.
func (mr *MockStateLedgerMockRecorder) AddressInAccessList(arg0 any) *StateLedgerAddressInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddressInAccessList", reflect.TypeOf((*MockStateLedger)(nil).AddressInAccessList), arg0)
	return &StateLedgerAddressInAccessListCall{Call: call}
}

// StateLedgerAddressInAccessListCall wrap *gomock.Call
type StateLedgerAddressInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerAddressInAccessListCall) Return(arg0 bool) *StateLedgerAddressInAccessListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerAddressInAccessListCall) Do(f func(types.Address) bool) *StateLedgerAddressInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerAddressInAccessListCall) DoAndReturn(f func(types.Address) bool) *StateLedgerAddressInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Clear mocks base method.
func (m *MockStateLedger) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateLedgerMockRecorder) Clear() *StateLedgerClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateLedger)(nil).Clear))
	return &StateLedgerClearCall{Call: call}
}

// StateLedgerClearCall wrap *gomock.Call
type StateLedgerClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerClearCall) Return() *StateLedgerClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerClearCall) Do(f func()) *StateLedgerClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerClearCall) DoAndReturn(f func()) *StateLedgerClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ClearChangerAndRefund mocks base method.
func (m *MockStateLedger) ClearChangerAndRefund() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ClearChangerAndRefund")
}

// ClearChangerAndRefund indicates an expected call of ClearChangerAndRefund.
func (mr *MockStateLedgerMockRecorder) ClearChangerAndRefund() *StateLedgerClearChangerAndRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearChangerAndRefund", reflect.TypeOf((*MockStateLedger)(nil).ClearChangerAndRefund))
	return &StateLedgerClearChangerAndRefundCall{Call: call}
}

// StateLedgerClearChangerAndRefundCall wrap *gomock.Call
type StateLedgerClearChangerAndRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerClearChangerAndRefundCall) Return() *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerClearChangerAndRefundCall) Do(f func()) *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerClearChangerAndRefundCall) DoAndReturn(f func()) *StateLedgerClearChangerAndRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockStateLedger) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockStateLedgerMockRecorder) Close() *StateLedgerCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockStateLedger)(nil).Close))
	return &StateLedgerCloseCall{Call: call}
}

// StateLedgerCloseCall wrap *gomock.Call
type StateLedgerCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerCloseCall) Return() *StateLedgerCloseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerCloseCall) Do(f func()) *StateLedgerCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerCloseCall) DoAndReturn(f func()) *StateLedgerCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateLedger) Commit() (*types.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(*types.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockStateLedgerMockRecorder) Commit() *StateLedgerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateLedger)(nil).Commit))
	return &StateLedgerCommitCall{Call: call}
}

// StateLedgerCommitCall wrap *gomock.Call
type StateLedgerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerCommitCall) Return(arg0 *types.Hash, arg1 error) *StateLedgerCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerCommitCall) Do(f func() (*types.Hash, error)) *StateLedgerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerCommitCall) DoAndReturn(f func() (*types.Hash, error)) *StateLedgerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Empty mocks base method.
func (m *MockStateLedger) Empty(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty.
func (mr *MockStateLedgerMockRecorder) Empty(arg0 any) *StateLedgerEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockStateLedger)(nil).Empty), arg0)
	return &StateLedgerEmptyCall{Call: call}
}

// StateLedgerEmptyCall wrap *gomock.Call
type StateLedgerEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerEmptyCall) Return(arg0 bool) *StateLedgerEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerEmptyCall) Do(f func(*types.Address) bool) *StateLedgerEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerEmptyCall) DoAndReturn(f func(*types.Address) bool) *StateLedgerEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exist mocks base method.
func (m *MockStateLedger) Exist(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockStateLedgerMockRecorder) Exist(arg0 any) *StateLedgerExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStateLedger)(nil).Exist), arg0)
	return &StateLedgerExistCall{Call: call}
}

// StateLedgerExistCall wrap *gomock.Call
type StateLedgerExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerExistCall) Return(arg0 bool) *StateLedgerExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerExistCall) Do(f func(*types.Address) bool) *StateLedgerExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerExistCall) DoAndReturn(f func(*types.Address) bool) *StateLedgerExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockStateLedger) Finalise() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Finalise")
}

// Finalise indicates an expected call of Finalise.
func (mr *MockStateLedgerMockRecorder) Finalise() *StateLedgerFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockStateLedger)(nil).Finalise))
	return &StateLedgerFinaliseCall{Call: call}
}

// StateLedgerFinaliseCall wrap *gomock.Call
type StateLedgerFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerFinaliseCall) Return() *StateLedgerFinaliseCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerFinaliseCall) Do(f func()) *StateLedgerFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerFinaliseCall) DoAndReturn(f func()) *StateLedgerFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateSnapshot mocks base method.
func (m *MockStateLedger) GenerateSnapshot(block *types.Block, errC chan error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "GenerateSnapshot", block, errC)
}

// GenerateSnapshot indicates an expected call of GenerateSnapshot.
func (mr *MockStateLedgerMockRecorder) GenerateSnapshot(block, errC any) *StateLedgerGenerateSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateSnapshot", reflect.TypeOf((*MockStateLedger)(nil).GenerateSnapshot), block, errC)
	return &StateLedgerGenerateSnapshotCall{Call: call}
}

// StateLedgerGenerateSnapshotCall wrap *gomock.Call
type StateLedgerGenerateSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGenerateSnapshotCall) Return() *StateLedgerGenerateSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGenerateSnapshotCall) Do(f func(*types.Block, chan error)) *StateLedgerGenerateSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGenerateSnapshotCall) DoAndReturn(f func(*types.Block, chan error)) *StateLedgerGenerateSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateLedger) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateLedgerMockRecorder) GetAccount(arg0 any) *StateLedgerGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateLedger)(nil).GetAccount), arg0)
	return &StateLedgerGetAccountCall{Call: call}
}

// StateLedgerGetAccountCall wrap *gomock.Call
type StateLedgerGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetAccountCall) Return(arg0 ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateLedgerGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateLedger) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateLedgerMockRecorder) GetBalance(arg0 any) *StateLedgerGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateLedger)(nil).GetBalance), arg0)
	return &StateLedgerGetBalanceCall{Call: call}
}

// StateLedgerGetBalanceCall wrap *gomock.Call
type StateLedgerGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetBalanceCall) Return(arg0 *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetBalanceCall) Do(f func(*types.Address) *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *StateLedgerGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateLedger) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateLedgerMockRecorder) GetCode(arg0 any) *StateLedgerGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateLedger)(nil).GetCode), arg0)
	return &StateLedgerGetCodeCall{Call: call}
}

// StateLedgerGetCodeCall wrap *gomock.Call
type StateLedgerGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetCodeCall) Return(arg0 []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetCodeCall) Do(f func(*types.Address) []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *StateLedgerGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeHash mocks base method.
func (m *MockStateLedger) GetCodeHash(arg0 *types.Address) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeHash", arg0)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetCodeHash indicates an expected call of GetCodeHash.
func (mr *MockStateLedgerMockRecorder) GetCodeHash(arg0 any) *StateLedgerGetCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeHash", reflect.TypeOf((*MockStateLedger)(nil).GetCodeHash), arg0)
	return &StateLedgerGetCodeHashCall{Call: call}
}

// StateLedgerGetCodeHashCall wrap *gomock.Call
type StateLedgerGetCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetCodeHashCall) Return(arg0 *types.Hash) *StateLedgerGetCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetCodeHashCall) Do(f func(*types.Address) *types.Hash) *StateLedgerGetCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetCodeHashCall) DoAndReturn(f func(*types.Address) *types.Hash) *StateLedgerGetCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeSize mocks base method.
func (m *MockStateLedger) GetCodeSize(arg0 *types.Address) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeSize", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetCodeSize indicates an expected call of GetCodeSize.
func (mr *MockStateLedgerMockRecorder) GetCodeSize(arg0 any) *StateLedgerGetCodeSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeSize", reflect.TypeOf((*MockStateLedger)(nil).GetCodeSize), arg0)
	return &StateLedgerGetCodeSizeCall{Call: call}
}

// StateLedgerGetCodeSizeCall wrap *gomock.Call
type StateLedgerGetCodeSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetCodeSizeCall) Return(arg0 int) *StateLedgerGetCodeSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetCodeSizeCall) Do(f func(*types.Address) int) *StateLedgerGetCodeSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetCodeSizeCall) DoAndReturn(f func(*types.Address) int) *StateLedgerGetCodeSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockStateLedger) GetCommittedState(arg0 *types.Address, arg1 []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockStateLedgerMockRecorder) GetCommittedState(arg0, arg1 any) *StateLedgerGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockStateLedger)(nil).GetCommittedState), arg0, arg1)
	return &StateLedgerGetCommittedStateCall{Call: call}
}

// StateLedgerGetCommittedStateCall wrap *gomock.Call
type StateLedgerGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetCommittedStateCall) Return(arg0 []byte) *StateLedgerGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetCommittedStateCall) Do(f func(*types.Address, []byte) []byte) *StateLedgerGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetCommittedStateCall) DoAndReturn(f func(*types.Address, []byte) []byte) *StateLedgerGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLogs mocks base method.
func (m *MockStateLedger) GetLogs(arg0 types.Hash, arg1 uint64, arg2 *types.Hash) []*types.EvmLog {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*types.EvmLog)
	return ret0
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockStateLedgerMockRecorder) GetLogs(arg0, arg1, arg2 any) *StateLedgerGetLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockStateLedger)(nil).GetLogs), arg0, arg1, arg2)
	return &StateLedgerGetLogsCall{Call: call}
}

// StateLedgerGetLogsCall wrap *gomock.Call
type StateLedgerGetLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetLogsCall) Return(arg0 []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetLogsCall) Do(f func(types.Hash, uint64, *types.Hash) []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetLogsCall) DoAndReturn(f func(types.Hash, uint64, *types.Hash) []*types.EvmLog) *StateLedgerGetLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateLedger) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateLedgerMockRecorder) GetNonce(arg0 any) *StateLedgerGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateLedger)(nil).GetNonce), arg0)
	return &StateLedgerGetNonceCall{Call: call}
}

// StateLedgerGetNonceCall wrap *gomock.Call
type StateLedgerGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetNonceCall) Return(arg0 uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetNonceCall) Do(f func(*types.Address) uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *StateLedgerGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateLedger) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateLedgerMockRecorder) GetOrCreateAccount(arg0 any) *StateLedgerGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateLedger)(nil).GetOrCreateAccount), arg0)
	return &StateLedgerGetOrCreateAccountCall{Call: call}
}

// StateLedgerGetOrCreateAccountCall wrap *gomock.Call
type StateLedgerGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateLedgerGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRefund mocks base method.
func (m *MockStateLedger) GetRefund() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRefund")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetRefund indicates an expected call of GetRefund.
func (mr *MockStateLedgerMockRecorder) GetRefund() *StateLedgerGetRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRefund", reflect.TypeOf((*MockStateLedger)(nil).GetRefund))
	return &StateLedgerGetRefundCall{Call: call}
}

// StateLedgerGetRefundCall wrap *gomock.Call
type StateLedgerGetRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetRefundCall) Return(arg0 uint64) *StateLedgerGetRefundCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetRefundCall) Do(f func() uint64) *StateLedgerGetRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetRefundCall) DoAndReturn(f func() uint64) *StateLedgerGetRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateLedger) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateLedgerMockRecorder) GetState(arg0, arg1 any) *StateLedgerGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateLedger)(nil).GetState), arg0, arg1)
	return &StateLedgerGetStateCall{Call: call}
}

// StateLedgerGetStateCall wrap *gomock.Call
type StateLedgerGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetStateCall) Return(arg0 bool, arg1 []byte) *StateLedgerGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *StateLedgerGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *StateLedgerGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTrieSnapshotMeta mocks base method.
func (m *MockStateLedger) GetTrieSnapshotMeta() (*ledger.SnapshotMeta, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTrieSnapshotMeta")
	ret0, _ := ret[0].(*ledger.SnapshotMeta)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTrieSnapshotMeta indicates an expected call of GetTrieSnapshotMeta.
func (mr *MockStateLedgerMockRecorder) GetTrieSnapshotMeta() *StateLedgerGetTrieSnapshotMetaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTrieSnapshotMeta", reflect.TypeOf((*MockStateLedger)(nil).GetTrieSnapshotMeta))
	return &StateLedgerGetTrieSnapshotMetaCall{Call: call}
}

// StateLedgerGetTrieSnapshotMetaCall wrap *gomock.Call
type StateLedgerGetTrieSnapshotMetaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerGetTrieSnapshotMetaCall) Return(arg0 *ledger.SnapshotMeta, arg1 error) *StateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerGetTrieSnapshotMetaCall) Do(f func() (*ledger.SnapshotMeta, error)) *StateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerGetTrieSnapshotMetaCall) DoAndReturn(f func() (*ledger.SnapshotMeta, error)) *StateLedgerGetTrieSnapshotMetaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasSuicide mocks base method.
func (m *MockStateLedger) HasSuicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSuicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSuicide indicates an expected call of HasSuicide.
func (mr *MockStateLedgerMockRecorder) HasSuicide(arg0 any) *StateLedgerHasSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSuicide", reflect.TypeOf((*MockStateLedger)(nil).HasSuicide), arg0)
	return &StateLedgerHasSuicideCall{Call: call}
}

// StateLedgerHasSuicideCall wrap *gomock.Call
type StateLedgerHasSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerHasSuicideCall) Return(arg0 bool) *StateLedgerHasSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerHasSuicideCall) Do(f func(*types.Address) bool) *StateLedgerHasSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerHasSuicideCall) DoAndReturn(f func(*types.Address) bool) *StateLedgerHasSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IterateTrie mocks base method.
func (m *MockStateLedger) IterateTrie(block *types.Block, kv storage.Storage, errC chan error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "IterateTrie", block, kv, errC)
}

// IterateTrie indicates an expected call of IterateTrie.
func (mr *MockStateLedgerMockRecorder) IterateTrie(block, kv, errC any) *StateLedgerIterateTrieCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IterateTrie", reflect.TypeOf((*MockStateLedger)(nil).IterateTrie), block, kv, errC)
	return &StateLedgerIterateTrieCall{Call: call}
}

// StateLedgerIterateTrieCall wrap *gomock.Call
type StateLedgerIterateTrieCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerIterateTrieCall) Return() *StateLedgerIterateTrieCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerIterateTrieCall) Do(f func(*types.Block, storage.Storage, chan error)) *StateLedgerIterateTrieCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerIterateTrieCall) DoAndReturn(f func(*types.Block, storage.Storage, chan error)) *StateLedgerIterateTrieCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewView mocks base method.
func (m *MockStateLedger) NewView(block *types.Block, enableSnapshot bool) ledger.StateLedger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewView", block, enableSnapshot)
	ret0, _ := ret[0].(ledger.StateLedger)
	return ret0
}

// NewView indicates an expected call of NewView.
func (mr *MockStateLedgerMockRecorder) NewView(block, enableSnapshot any) *StateLedgerNewViewCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewView", reflect.TypeOf((*MockStateLedger)(nil).NewView), block, enableSnapshot)
	return &StateLedgerNewViewCall{Call: call}
}

// StateLedgerNewViewCall wrap *gomock.Call
type StateLedgerNewViewCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerNewViewCall) Return(arg0 ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerNewViewCall) Do(f func(*types.Block, bool) ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerNewViewCall) DoAndReturn(f func(*types.Block, bool) ledger.StateLedger) *StateLedgerNewViewCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// NewViewWithoutCache mocks base method.
func (m *MockStateLedger) NewViewWithoutCache(block *types.Block, enableSnapshot bool) ledger.StateLedger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewViewWithoutCache", block, enableSnapshot)
	ret0, _ := ret[0].(ledger.StateLedger)
	return ret0
}

// NewViewWithoutCache indicates an expected call of NewViewWithoutCache.
func (mr *MockStateLedgerMockRecorder) NewViewWithoutCache(block, enableSnapshot any) *StateLedgerNewViewWithoutCacheCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewViewWithoutCache", reflect.TypeOf((*MockStateLedger)(nil).NewViewWithoutCache), block, enableSnapshot)
	return &StateLedgerNewViewWithoutCacheCall{Call: call}
}

// StateLedgerNewViewWithoutCacheCall wrap *gomock.Call
type StateLedgerNewViewWithoutCacheCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerNewViewWithoutCacheCall) Return(arg0 ledger.StateLedger) *StateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerNewViewWithoutCacheCall) Do(f func(*types.Block, bool) ledger.StateLedger) *StateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerNewViewWithoutCacheCall) DoAndReturn(f func(*types.Block, bool) ledger.StateLedger) *StateLedgerNewViewWithoutCacheCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrepareBlock mocks base method.
func (m *MockStateLedger) PrepareBlock(arg0, arg1 *types.Hash, arg2 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PrepareBlock", arg0, arg1, arg2)
}

// PrepareBlock indicates an expected call of PrepareBlock.
func (mr *MockStateLedgerMockRecorder) PrepareBlock(arg0, arg1, arg2 any) *StateLedgerPrepareBlockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrepareBlock", reflect.TypeOf((*MockStateLedger)(nil).PrepareBlock), arg0, arg1, arg2)
	return &StateLedgerPrepareBlockCall{Call: call}
}

// StateLedgerPrepareBlockCall wrap *gomock.Call
type StateLedgerPrepareBlockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerPrepareBlockCall) Return() *StateLedgerPrepareBlockCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerPrepareBlockCall) Do(f func(*types.Hash, *types.Hash, uint64)) *StateLedgerPrepareBlockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerPrepareBlockCall) DoAndReturn(f func(*types.Hash, *types.Hash, uint64)) *StateLedgerPrepareBlockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Prove mocks base method.
func (m *MockStateLedger) Prove(rootHash common.Hash, key []byte) (*jmt.ProofResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prove", rootHash, key)
	ret0, _ := ret[0].(*jmt.ProofResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prove indicates an expected call of Prove.
func (mr *MockStateLedgerMockRecorder) Prove(rootHash, key any) *StateLedgerProveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prove", reflect.TypeOf((*MockStateLedger)(nil).Prove), rootHash, key)
	return &StateLedgerProveCall{Call: call}
}

// StateLedgerProveCall wrap *gomock.Call
type StateLedgerProveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerProveCall) Return(arg0 *jmt.ProofResult, arg1 error) *StateLedgerProveCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerProveCall) Do(f func(common.Hash, []byte) (*jmt.ProofResult, error)) *StateLedgerProveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerProveCall) DoAndReturn(f func(common.Hash, []byte) (*jmt.ProofResult, error)) *StateLedgerProveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertToSnapshot mocks base method.
func (m *MockStateLedger) RevertToSnapshot(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RevertToSnapshot", arg0)
}

// RevertToSnapshot indicates an expected call of RevertToSnapshot.
func (mr *MockStateLedgerMockRecorder) RevertToSnapshot(arg0 any) *StateLedgerRevertToSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertToSnapshot", reflect.TypeOf((*MockStateLedger)(nil).RevertToSnapshot), arg0)
	return &StateLedgerRevertToSnapshotCall{Call: call}
}

// StateLedgerRevertToSnapshotCall wrap *gomock.Call
type StateLedgerRevertToSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerRevertToSnapshotCall) Return() *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerRevertToSnapshotCall) Do(f func(int)) *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerRevertToSnapshotCall) DoAndReturn(f func(int)) *StateLedgerRevertToSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RollbackState mocks base method.
func (m *MockStateLedger) RollbackState(height uint64, lastStateRoot *types.Hash) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackState", height, lastStateRoot)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackState indicates an expected call of RollbackState.
func (mr *MockStateLedgerMockRecorder) RollbackState(height, lastStateRoot any) *StateLedgerRollbackStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackState", reflect.TypeOf((*MockStateLedger)(nil).RollbackState), height, lastStateRoot)
	return &StateLedgerRollbackStateCall{Call: call}
}

// StateLedgerRollbackStateCall wrap *gomock.Call
type StateLedgerRollbackStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerRollbackStateCall) Return(arg0 error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerRollbackStateCall) Do(f func(uint64, *types.Hash) error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerRollbackStateCall) DoAndReturn(f func(uint64, *types.Hash) error) *StateLedgerRollbackStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateLedger) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateLedgerMockRecorder) SetBalance(arg0, arg1 any) *StateLedgerSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateLedger)(nil).SetBalance), arg0, arg1)
	return &StateLedgerSetBalanceCall{Call: call}
}

// StateLedgerSetBalanceCall wrap *gomock.Call
type StateLedgerSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetBalanceCall) Return() *StateLedgerSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetBalanceCall) Do(f func(*types.Address, *big.Int)) *StateLedgerSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateLedgerSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateLedger) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateLedgerMockRecorder) SetCode(arg0, arg1 any) *StateLedgerSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateLedger)(nil).SetCode), arg0, arg1)
	return &StateLedgerSetCodeCall{Call: call}
}

// StateLedgerSetCodeCall wrap *gomock.Call
type StateLedgerSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetCodeCall) Return() *StateLedgerSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetCodeCall) Do(f func(*types.Address, []byte)) *StateLedgerSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *StateLedgerSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateLedger) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateLedgerMockRecorder) SetNonce(arg0, arg1 any) *StateLedgerSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateLedger)(nil).SetNonce), arg0, arg1)
	return &StateLedgerSetNonceCall{Call: call}
}

// StateLedgerSetNonceCall wrap *gomock.Call
type StateLedgerSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetNonceCall) Return() *StateLedgerSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetNonceCall) Do(f func(*types.Address, uint64)) *StateLedgerSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *StateLedgerSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateLedger) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateLedgerMockRecorder) SetState(arg0, arg1, arg2 any) *StateLedgerSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateLedger)(nil).SetState), arg0, arg1, arg2)
	return &StateLedgerSetStateCall{Call: call}
}

// StateLedgerSetStateCall wrap *gomock.Call
type StateLedgerSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetStateCall) Return() *StateLedgerSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetStateCall) Do(f func(*types.Address, []byte, []byte)) *StateLedgerSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *StateLedgerSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateLedger) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateLedgerMockRecorder) SetTxContext(thash, txIndex any) *StateLedgerSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateLedger)(nil).SetTxContext), thash, txIndex)
	return &StateLedgerSetTxContextCall{Call: call}
}

// StateLedgerSetTxContextCall wrap *gomock.Call
type StateLedgerSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSetTxContextCall) Return() *StateLedgerSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSetTxContextCall) Do(f func(*types.Hash, int)) *StateLedgerSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *StateLedgerSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlotInAccessList mocks base method.
func (m *MockStateLedger) SlotInAccessList(arg0 types.Address, arg1 types.Hash) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlotInAccessList", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// SlotInAccessList indicates an expected call of SlotInAccessList.
func (mr *MockStateLedgerMockRecorder) SlotInAccessList(arg0, arg1 any) *StateLedgerSlotInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlotInAccessList", reflect.TypeOf((*MockStateLedger)(nil).SlotInAccessList), arg0, arg1)
	return &StateLedgerSlotInAccessListCall{Call: call}
}

// StateLedgerSlotInAccessListCall wrap *gomock.Call
type StateLedgerSlotInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSlotInAccessListCall) Return(arg0, arg1 bool) *StateLedgerSlotInAccessListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSlotInAccessListCall) Do(f func(types.Address, types.Hash) (bool, bool)) *StateLedgerSlotInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSlotInAccessListCall) DoAndReturn(f func(types.Address, types.Hash) (bool, bool)) *StateLedgerSlotInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockStateLedger) Snapshot() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(int)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockStateLedgerMockRecorder) Snapshot() *StateLedgerSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockStateLedger)(nil).Snapshot))
	return &StateLedgerSnapshotCall{Call: call}
}

// StateLedgerSnapshotCall wrap *gomock.Call
type StateLedgerSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSnapshotCall) Return(arg0 int) *StateLedgerSnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSnapshotCall) Do(f func() int) *StateLedgerSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSnapshotCall) DoAndReturn(f func() int) *StateLedgerSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockStateLedger) SubBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", arg0, arg1)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockStateLedgerMockRecorder) SubBalance(arg0, arg1 any) *StateLedgerSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockStateLedger)(nil).SubBalance), arg0, arg1)
	return &StateLedgerSubBalanceCall{Call: call}
}

// StateLedgerSubBalanceCall wrap *gomock.Call
type StateLedgerSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSubBalanceCall) Return() *StateLedgerSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSubBalanceCall) Do(f func(*types.Address, *big.Int)) *StateLedgerSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSubBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateLedgerSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubRefund mocks base method.
func (m *MockStateLedger) SubRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubRefund", arg0)
}

// SubRefund indicates an expected call of SubRefund.
func (mr *MockStateLedgerMockRecorder) SubRefund(arg0 any) *StateLedgerSubRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubRefund", reflect.TypeOf((*MockStateLedger)(nil).SubRefund), arg0)
	return &StateLedgerSubRefundCall{Call: call}
}

// StateLedgerSubRefundCall wrap *gomock.Call
type StateLedgerSubRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSubRefundCall) Return() *StateLedgerSubRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSubRefundCall) Do(f func(uint64)) *StateLedgerSubRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSubRefundCall) DoAndReturn(f func(uint64)) *StateLedgerSubRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicide mocks base method.
func (m *MockStateLedger) Suicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicide indicates an expected call of Suicide.
func (mr *MockStateLedgerMockRecorder) Suicide(arg0 any) *StateLedgerSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicide", reflect.TypeOf((*MockStateLedger)(nil).Suicide), arg0)
	return &StateLedgerSuicideCall{Call: call}
}

// StateLedgerSuicideCall wrap *gomock.Call
type StateLedgerSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerSuicideCall) Return(arg0 bool) *StateLedgerSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerSuicideCall) Do(f func(*types.Address) bool) *StateLedgerSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerSuicideCall) DoAndReturn(f func(*types.Address) bool) *StateLedgerSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// VerifyTrie mocks base method.
func (m *MockStateLedger) VerifyTrie(block *types.Block) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyTrie", block)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// VerifyTrie indicates an expected call of VerifyTrie.
func (mr *MockStateLedgerMockRecorder) VerifyTrie(block any) *StateLedgerVerifyTrieCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyTrie", reflect.TypeOf((*MockStateLedger)(nil).VerifyTrie), block)
	return &StateLedgerVerifyTrieCall{Call: call}
}

// StateLedgerVerifyTrieCall wrap *gomock.Call
type StateLedgerVerifyTrieCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerVerifyTrieCall) Return(arg0 bool, arg1 error) *StateLedgerVerifyTrieCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerVerifyTrieCall) Do(f func(*types.Block) (bool, error)) *StateLedgerVerifyTrieCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerVerifyTrieCall) DoAndReturn(f func(*types.Block) (bool, error)) *StateLedgerVerifyTrieCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Version mocks base method.
func (m *MockStateLedger) Version() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Version")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// Version indicates an expected call of Version.
func (mr *MockStateLedgerMockRecorder) Version() *StateLedgerVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Version", reflect.TypeOf((*MockStateLedger)(nil).Version))
	return &StateLedgerVersionCall{Call: call}
}

// StateLedgerVersionCall wrap *gomock.Call
type StateLedgerVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateLedgerVersionCall) Return(arg0 uint64) *StateLedgerVersionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateLedgerVersionCall) Do(f func() uint64) *StateLedgerVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateLedgerVersionCall) DoAndReturn(f func() uint64) *StateLedgerVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockStateAccessor is a mock of StateAccessor interface.
type MockStateAccessor struct {
	ctrl     *gomock.Controller
	recorder *MockStateAccessorMockRecorder
}

// MockStateAccessorMockRecorder is the mock recorder for MockStateAccessor.
type MockStateAccessorMockRecorder struct {
	mock *MockStateAccessor
}

// NewMockStateAccessor creates a new mock instance.
func NewMockStateAccessor(ctrl *gomock.Controller) *MockStateAccessor {
	mock := &MockStateAccessor{ctrl: ctrl}
	mock.recorder = &MockStateAccessorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStateAccessor) EXPECT() *MockStateAccessorMockRecorder {
	return m.recorder
}

// AddAddressToAccessList mocks base method.
func (m *MockStateAccessor) AddAddressToAccessList(arg0 types.Address) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddAddressToAccessList", arg0)
}

// AddAddressToAccessList indicates an expected call of AddAddressToAccessList.
func (mr *MockStateAccessorMockRecorder) AddAddressToAccessList(arg0 any) *StateAccessorAddAddressToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddAddressToAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddAddressToAccessList), arg0)
	return &StateAccessorAddAddressToAccessListCall{Call: call}
}

// StateAccessorAddAddressToAccessListCall wrap *gomock.Call
type StateAccessorAddAddressToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddAddressToAccessListCall) Return() *StateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddAddressToAccessListCall) Do(f func(types.Address)) *StateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddAddressToAccessListCall) DoAndReturn(f func(types.Address)) *StateAccessorAddAddressToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddBalance mocks base method.
func (m *MockStateAccessor) AddBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", arg0, arg1)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockStateAccessorMockRecorder) AddBalance(arg0, arg1 any) *StateAccessorAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockStateAccessor)(nil).AddBalance), arg0, arg1)
	return &StateAccessorAddBalanceCall{Call: call}
}

// StateAccessorAddBalanceCall wrap *gomock.Call
type StateAccessorAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddBalanceCall) Return() *StateAccessorAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddBalanceCall) Do(f func(*types.Address, *big.Int)) *StateAccessorAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateAccessorAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPreimage mocks base method.
func (m *MockStateAccessor) AddPreimage(arg0 types.Hash, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddPreimage", arg0, arg1)
}

// AddPreimage indicates an expected call of AddPreimage.
func (mr *MockStateAccessorMockRecorder) AddPreimage(arg0, arg1 any) *StateAccessorAddPreimageCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPreimage", reflect.TypeOf((*MockStateAccessor)(nil).AddPreimage), arg0, arg1)
	return &StateAccessorAddPreimageCall{Call: call}
}

// StateAccessorAddPreimageCall wrap *gomock.Call
type StateAccessorAddPreimageCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddPreimageCall) Return() *StateAccessorAddPreimageCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddPreimageCall) Do(f func(types.Hash, []byte)) *StateAccessorAddPreimageCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddPreimageCall) DoAndReturn(f func(types.Hash, []byte)) *StateAccessorAddPreimageCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRefund mocks base method.
func (m *MockStateAccessor) AddRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRefund", arg0)
}

// AddRefund indicates an expected call of AddRefund.
func (mr *MockStateAccessorMockRecorder) AddRefund(arg0 any) *StateAccessorAddRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRefund", reflect.TypeOf((*MockStateAccessor)(nil).AddRefund), arg0)
	return &StateAccessorAddRefundCall{Call: call}
}

// StateAccessorAddRefundCall wrap *gomock.Call
type StateAccessorAddRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddRefundCall) Return() *StateAccessorAddRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddRefundCall) Do(f func(uint64)) *StateAccessorAddRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddRefundCall) DoAndReturn(f func(uint64)) *StateAccessorAddRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddSlotToAccessList mocks base method.
func (m *MockStateAccessor) AddSlotToAccessList(arg0 types.Address, arg1 types.Hash) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddSlotToAccessList", arg0, arg1)
}

// AddSlotToAccessList indicates an expected call of AddSlotToAccessList.
func (mr *MockStateAccessorMockRecorder) AddSlotToAccessList(arg0, arg1 any) *StateAccessorAddSlotToAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSlotToAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddSlotToAccessList), arg0, arg1)
	return &StateAccessorAddSlotToAccessListCall{Call: call}
}

// StateAccessorAddSlotToAccessListCall wrap *gomock.Call
type StateAccessorAddSlotToAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddSlotToAccessListCall) Return() *StateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddSlotToAccessListCall) Do(f func(types.Address, types.Hash)) *StateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddSlotToAccessListCall) DoAndReturn(f func(types.Address, types.Hash)) *StateAccessorAddSlotToAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddressInAccessList mocks base method.
func (m *MockStateAccessor) AddressInAccessList(arg0 types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddressInAccessList", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// AddressInAccessList indicates an expected call of AddressInAccessList.
func (mr *MockStateAccessorMockRecorder) AddressInAccessList(arg0 any) *StateAccessorAddressInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddressInAccessList", reflect.TypeOf((*MockStateAccessor)(nil).AddressInAccessList), arg0)
	return &StateAccessorAddressInAccessListCall{Call: call}
}

// StateAccessorAddressInAccessListCall wrap *gomock.Call
type StateAccessorAddressInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorAddressInAccessListCall) Return(arg0 bool) *StateAccessorAddressInAccessListCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorAddressInAccessListCall) Do(f func(types.Address) bool) *StateAccessorAddressInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorAddressInAccessListCall) DoAndReturn(f func(types.Address) bool) *StateAccessorAddressInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Clear mocks base method.
func (m *MockStateAccessor) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockStateAccessorMockRecorder) Clear() *StateAccessorClearCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockStateAccessor)(nil).Clear))
	return &StateAccessorClearCall{Call: call}
}

// StateAccessorClearCall wrap *gomock.Call
type StateAccessorClearCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorClearCall) Return() *StateAccessorClearCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorClearCall) Do(f func()) *StateAccessorClearCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorClearCall) DoAndReturn(f func()) *StateAccessorClearCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockStateAccessor) Commit() (*types.Hash, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(*types.Hash)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Commit indicates an expected call of Commit.
func (mr *MockStateAccessorMockRecorder) Commit() *StateAccessorCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStateAccessor)(nil).Commit))
	return &StateAccessorCommitCall{Call: call}
}

// StateAccessorCommitCall wrap *gomock.Call
type StateAccessorCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorCommitCall) Return(arg0 *types.Hash, arg1 error) *StateAccessorCommitCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorCommitCall) Do(f func() (*types.Hash, error)) *StateAccessorCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorCommitCall) DoAndReturn(f func() (*types.Hash, error)) *StateAccessorCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Empty mocks base method.
func (m *MockStateAccessor) Empty(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty.
func (mr *MockStateAccessorMockRecorder) Empty(arg0 any) *StateAccessorEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockStateAccessor)(nil).Empty), arg0)
	return &StateAccessorEmptyCall{Call: call}
}

// StateAccessorEmptyCall wrap *gomock.Call
type StateAccessorEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorEmptyCall) Return(arg0 bool) *StateAccessorEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorEmptyCall) Do(f func(*types.Address) bool) *StateAccessorEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorEmptyCall) DoAndReturn(f func(*types.Address) bool) *StateAccessorEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exist mocks base method.
func (m *MockStateAccessor) Exist(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exist indicates an expected call of Exist.
func (mr *MockStateAccessorMockRecorder) Exist(arg0 any) *StateAccessorExistCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStateAccessor)(nil).Exist), arg0)
	return &StateAccessorExistCall{Call: call}
}

// StateAccessorExistCall wrap *gomock.Call
type StateAccessorExistCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorExistCall) Return(arg0 bool) *StateAccessorExistCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorExistCall) Do(f func(*types.Address) bool) *StateAccessorExistCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorExistCall) DoAndReturn(f func(*types.Address) bool) *StateAccessorExistCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockStateAccessor) GetAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockStateAccessorMockRecorder) GetAccount(arg0 any) *StateAccessorGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetAccount), arg0)
	return &StateAccessorGetAccountCall{Call: call}
}

// StateAccessorGetAccountCall wrap *gomock.Call
type StateAccessorGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetAccountCall) Return(arg0 ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateAccessorGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockStateAccessor) GetBalance(arg0 *types.Address) *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance", arg0)
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockStateAccessorMockRecorder) GetBalance(arg0 any) *StateAccessorGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockStateAccessor)(nil).GetBalance), arg0)
	return &StateAccessorGetBalanceCall{Call: call}
}

// StateAccessorGetBalanceCall wrap *gomock.Call
type StateAccessorGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetBalanceCall) Return(arg0 *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetBalanceCall) Do(f func(*types.Address) *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetBalanceCall) DoAndReturn(f func(*types.Address) *big.Int) *StateAccessorGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCode mocks base method.
func (m *MockStateAccessor) GetCode(arg0 *types.Address) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCode", arg0)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCode indicates an expected call of GetCode.
func (mr *MockStateAccessorMockRecorder) GetCode(arg0 any) *StateAccessorGetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCode", reflect.TypeOf((*MockStateAccessor)(nil).GetCode), arg0)
	return &StateAccessorGetCodeCall{Call: call}
}

// StateAccessorGetCodeCall wrap *gomock.Call
type StateAccessorGetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetCodeCall) Return(arg0 []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetCodeCall) Do(f func(*types.Address) []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetCodeCall) DoAndReturn(f func(*types.Address) []byte) *StateAccessorGetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeHash mocks base method.
func (m *MockStateAccessor) GetCodeHash(arg0 *types.Address) *types.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeHash", arg0)
	ret0, _ := ret[0].(*types.Hash)
	return ret0
}

// GetCodeHash indicates an expected call of GetCodeHash.
func (mr *MockStateAccessorMockRecorder) GetCodeHash(arg0 any) *StateAccessorGetCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeHash", reflect.TypeOf((*MockStateAccessor)(nil).GetCodeHash), arg0)
	return &StateAccessorGetCodeHashCall{Call: call}
}

// StateAccessorGetCodeHashCall wrap *gomock.Call
type StateAccessorGetCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetCodeHashCall) Return(arg0 *types.Hash) *StateAccessorGetCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetCodeHashCall) Do(f func(*types.Address) *types.Hash) *StateAccessorGetCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetCodeHashCall) DoAndReturn(f func(*types.Address) *types.Hash) *StateAccessorGetCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCodeSize mocks base method.
func (m *MockStateAccessor) GetCodeSize(arg0 *types.Address) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCodeSize", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// GetCodeSize indicates an expected call of GetCodeSize.
func (mr *MockStateAccessorMockRecorder) GetCodeSize(arg0 any) *StateAccessorGetCodeSizeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCodeSize", reflect.TypeOf((*MockStateAccessor)(nil).GetCodeSize), arg0)
	return &StateAccessorGetCodeSizeCall{Call: call}
}

// StateAccessorGetCodeSizeCall wrap *gomock.Call
type StateAccessorGetCodeSizeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetCodeSizeCall) Return(arg0 int) *StateAccessorGetCodeSizeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetCodeSizeCall) Do(f func(*types.Address) int) *StateAccessorGetCodeSizeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetCodeSizeCall) DoAndReturn(f func(*types.Address) int) *StateAccessorGetCodeSizeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockStateAccessor) GetCommittedState(arg0 *types.Address, arg1 []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", arg0, arg1)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockStateAccessorMockRecorder) GetCommittedState(arg0, arg1 any) *StateAccessorGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockStateAccessor)(nil).GetCommittedState), arg0, arg1)
	return &StateAccessorGetCommittedStateCall{Call: call}
}

// StateAccessorGetCommittedStateCall wrap *gomock.Call
type StateAccessorGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetCommittedStateCall) Return(arg0 []byte) *StateAccessorGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetCommittedStateCall) Do(f func(*types.Address, []byte) []byte) *StateAccessorGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetCommittedStateCall) DoAndReturn(f func(*types.Address, []byte) []byte) *StateAccessorGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockStateAccessor) GetNonce(arg0 *types.Address) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockStateAccessorMockRecorder) GetNonce(arg0 any) *StateAccessorGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockStateAccessor)(nil).GetNonce), arg0)
	return &StateAccessorGetNonceCall{Call: call}
}

// StateAccessorGetNonceCall wrap *gomock.Call
type StateAccessorGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetNonceCall) Return(arg0 uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetNonceCall) Do(f func(*types.Address) uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetNonceCall) DoAndReturn(f func(*types.Address) uint64) *StateAccessorGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetOrCreateAccount mocks base method.
func (m *MockStateAccessor) GetOrCreateAccount(arg0 *types.Address) ledger.IAccount {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrCreateAccount", arg0)
	ret0, _ := ret[0].(ledger.IAccount)
	return ret0
}

// GetOrCreateAccount indicates an expected call of GetOrCreateAccount.
func (mr *MockStateAccessorMockRecorder) GetOrCreateAccount(arg0 any) *StateAccessorGetOrCreateAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrCreateAccount", reflect.TypeOf((*MockStateAccessor)(nil).GetOrCreateAccount), arg0)
	return &StateAccessorGetOrCreateAccountCall{Call: call}
}

// StateAccessorGetOrCreateAccountCall wrap *gomock.Call
type StateAccessorGetOrCreateAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetOrCreateAccountCall) Return(arg0 ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetOrCreateAccountCall) Do(f func(*types.Address) ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetOrCreateAccountCall) DoAndReturn(f func(*types.Address) ledger.IAccount) *StateAccessorGetOrCreateAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRefund mocks base method.
func (m *MockStateAccessor) GetRefund() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRefund")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetRefund indicates an expected call of GetRefund.
func (mr *MockStateAccessorMockRecorder) GetRefund() *StateAccessorGetRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRefund", reflect.TypeOf((*MockStateAccessor)(nil).GetRefund))
	return &StateAccessorGetRefundCall{Call: call}
}

// StateAccessorGetRefundCall wrap *gomock.Call
type StateAccessorGetRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetRefundCall) Return(arg0 uint64) *StateAccessorGetRefundCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetRefundCall) Do(f func() uint64) *StateAccessorGetRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetRefundCall) DoAndReturn(f func() uint64) *StateAccessorGetRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockStateAccessor) GetState(arg0 *types.Address, arg1 []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockStateAccessorMockRecorder) GetState(arg0, arg1 any) *StateAccessorGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockStateAccessor)(nil).GetState), arg0, arg1)
	return &StateAccessorGetStateCall{Call: call}
}

// StateAccessorGetStateCall wrap *gomock.Call
type StateAccessorGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorGetStateCall) Return(arg0 bool, arg1 []byte) *StateAccessorGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorGetStateCall) Do(f func(*types.Address, []byte) (bool, []byte)) *StateAccessorGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorGetStateCall) DoAndReturn(f func(*types.Address, []byte) (bool, []byte)) *StateAccessorGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasSuicide mocks base method.
func (m *MockStateAccessor) HasSuicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasSuicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasSuicide indicates an expected call of HasSuicide.
func (mr *MockStateAccessorMockRecorder) HasSuicide(arg0 any) *StateAccessorHasSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasSuicide", reflect.TypeOf((*MockStateAccessor)(nil).HasSuicide), arg0)
	return &StateAccessorHasSuicideCall{Call: call}
}

// StateAccessorHasSuicideCall wrap *gomock.Call
type StateAccessorHasSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorHasSuicideCall) Return(arg0 bool) *StateAccessorHasSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorHasSuicideCall) Do(f func(*types.Address) bool) *StateAccessorHasSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorHasSuicideCall) DoAndReturn(f func(*types.Address) bool) *StateAccessorHasSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertToSnapshot mocks base method.
func (m *MockStateAccessor) RevertToSnapshot(arg0 int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RevertToSnapshot", arg0)
}

// RevertToSnapshot indicates an expected call of RevertToSnapshot.
func (mr *MockStateAccessorMockRecorder) RevertToSnapshot(arg0 any) *StateAccessorRevertToSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertToSnapshot", reflect.TypeOf((*MockStateAccessor)(nil).RevertToSnapshot), arg0)
	return &StateAccessorRevertToSnapshotCall{Call: call}
}

// StateAccessorRevertToSnapshotCall wrap *gomock.Call
type StateAccessorRevertToSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorRevertToSnapshotCall) Return() *StateAccessorRevertToSnapshotCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorRevertToSnapshotCall) Do(f func(int)) *StateAccessorRevertToSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorRevertToSnapshotCall) DoAndReturn(f func(int)) *StateAccessorRevertToSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockStateAccessor) SetBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", arg0, arg1)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockStateAccessorMockRecorder) SetBalance(arg0, arg1 any) *StateAccessorSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockStateAccessor)(nil).SetBalance), arg0, arg1)
	return &StateAccessorSetBalanceCall{Call: call}
}

// StateAccessorSetBalanceCall wrap *gomock.Call
type StateAccessorSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetBalanceCall) Return() *StateAccessorSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetBalanceCall) Do(f func(*types.Address, *big.Int)) *StateAccessorSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateAccessorSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCode mocks base method.
func (m *MockStateAccessor) SetCode(arg0 *types.Address, arg1 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCode", arg0, arg1)
}

// SetCode indicates an expected call of SetCode.
func (mr *MockStateAccessorMockRecorder) SetCode(arg0, arg1 any) *StateAccessorSetCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCode", reflect.TypeOf((*MockStateAccessor)(nil).SetCode), arg0, arg1)
	return &StateAccessorSetCodeCall{Call: call}
}

// StateAccessorSetCodeCall wrap *gomock.Call
type StateAccessorSetCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetCodeCall) Return() *StateAccessorSetCodeCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetCodeCall) Do(f func(*types.Address, []byte)) *StateAccessorSetCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetCodeCall) DoAndReturn(f func(*types.Address, []byte)) *StateAccessorSetCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockStateAccessor) SetNonce(arg0 *types.Address, arg1 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", arg0, arg1)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockStateAccessorMockRecorder) SetNonce(arg0, arg1 any) *StateAccessorSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockStateAccessor)(nil).SetNonce), arg0, arg1)
	return &StateAccessorSetNonceCall{Call: call}
}

// StateAccessorSetNonceCall wrap *gomock.Call
type StateAccessorSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetNonceCall) Return() *StateAccessorSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetNonceCall) Do(f func(*types.Address, uint64)) *StateAccessorSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetNonceCall) DoAndReturn(f func(*types.Address, uint64)) *StateAccessorSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockStateAccessor) SetState(arg0 *types.Address, arg1, arg2 []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", arg0, arg1, arg2)
}

// SetState indicates an expected call of SetState.
func (mr *MockStateAccessorMockRecorder) SetState(arg0, arg1, arg2 any) *StateAccessorSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockStateAccessor)(nil).SetState), arg0, arg1, arg2)
	return &StateAccessorSetStateCall{Call: call}
}

// StateAccessorSetStateCall wrap *gomock.Call
type StateAccessorSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetStateCall) Return() *StateAccessorSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetStateCall) Do(f func(*types.Address, []byte, []byte)) *StateAccessorSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetStateCall) DoAndReturn(f func(*types.Address, []byte, []byte)) *StateAccessorSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetTxContext mocks base method.
func (m *MockStateAccessor) SetTxContext(thash *types.Hash, txIndex int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetTxContext", thash, txIndex)
}

// SetTxContext indicates an expected call of SetTxContext.
func (mr *MockStateAccessorMockRecorder) SetTxContext(thash, txIndex any) *StateAccessorSetTxContextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTxContext", reflect.TypeOf((*MockStateAccessor)(nil).SetTxContext), thash, txIndex)
	return &StateAccessorSetTxContextCall{Call: call}
}

// StateAccessorSetTxContextCall wrap *gomock.Call
type StateAccessorSetTxContextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSetTxContextCall) Return() *StateAccessorSetTxContextCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSetTxContextCall) Do(f func(*types.Hash, int)) *StateAccessorSetTxContextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSetTxContextCall) DoAndReturn(f func(*types.Hash, int)) *StateAccessorSetTxContextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SlotInAccessList mocks base method.
func (m *MockStateAccessor) SlotInAccessList(arg0 types.Address, arg1 types.Hash) (bool, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SlotInAccessList", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// SlotInAccessList indicates an expected call of SlotInAccessList.
func (mr *MockStateAccessorMockRecorder) SlotInAccessList(arg0, arg1 any) *StateAccessorSlotInAccessListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SlotInAccessList", reflect.TypeOf((*MockStateAccessor)(nil).SlotInAccessList), arg0, arg1)
	return &StateAccessorSlotInAccessListCall{Call: call}
}

// StateAccessorSlotInAccessListCall wrap *gomock.Call
type StateAccessorSlotInAccessListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSlotInAccessListCall) Return(arg0, arg1 bool) *StateAccessorSlotInAccessListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSlotInAccessListCall) Do(f func(types.Address, types.Hash) (bool, bool)) *StateAccessorSlotInAccessListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSlotInAccessListCall) DoAndReturn(f func(types.Address, types.Hash) (bool, bool)) *StateAccessorSlotInAccessListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Snapshot mocks base method.
func (m *MockStateAccessor) Snapshot() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Snapshot")
	ret0, _ := ret[0].(int)
	return ret0
}

// Snapshot indicates an expected call of Snapshot.
func (mr *MockStateAccessorMockRecorder) Snapshot() *StateAccessorSnapshotCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Snapshot", reflect.TypeOf((*MockStateAccessor)(nil).Snapshot))
	return &StateAccessorSnapshotCall{Call: call}
}

// StateAccessorSnapshotCall wrap *gomock.Call
type StateAccessorSnapshotCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSnapshotCall) Return(arg0 int) *StateAccessorSnapshotCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSnapshotCall) Do(f func() int) *StateAccessorSnapshotCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSnapshotCall) DoAndReturn(f func() int) *StateAccessorSnapshotCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockStateAccessor) SubBalance(arg0 *types.Address, arg1 *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", arg0, arg1)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockStateAccessorMockRecorder) SubBalance(arg0, arg1 any) *StateAccessorSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockStateAccessor)(nil).SubBalance), arg0, arg1)
	return &StateAccessorSubBalanceCall{Call: call}
}

// StateAccessorSubBalanceCall wrap *gomock.Call
type StateAccessorSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSubBalanceCall) Return() *StateAccessorSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSubBalanceCall) Do(f func(*types.Address, *big.Int)) *StateAccessorSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSubBalanceCall) DoAndReturn(f func(*types.Address, *big.Int)) *StateAccessorSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubRefund mocks base method.
func (m *MockStateAccessor) SubRefund(arg0 uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubRefund", arg0)
}

// SubRefund indicates an expected call of SubRefund.
func (mr *MockStateAccessorMockRecorder) SubRefund(arg0 any) *StateAccessorSubRefundCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubRefund", reflect.TypeOf((*MockStateAccessor)(nil).SubRefund), arg0)
	return &StateAccessorSubRefundCall{Call: call}
}

// StateAccessorSubRefundCall wrap *gomock.Call
type StateAccessorSubRefundCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSubRefundCall) Return() *StateAccessorSubRefundCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSubRefundCall) Do(f func(uint64)) *StateAccessorSubRefundCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSubRefundCall) DoAndReturn(f func(uint64)) *StateAccessorSubRefundCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicide mocks base method.
func (m *MockStateAccessor) Suicide(arg0 *types.Address) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicide", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicide indicates an expected call of Suicide.
func (mr *MockStateAccessorMockRecorder) Suicide(arg0 any) *StateAccessorSuicideCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicide", reflect.TypeOf((*MockStateAccessor)(nil).Suicide), arg0)
	return &StateAccessorSuicideCall{Call: call}
}

// StateAccessorSuicideCall wrap *gomock.Call
type StateAccessorSuicideCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *StateAccessorSuicideCall) Return(arg0 bool) *StateAccessorSuicideCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *StateAccessorSuicideCall) Do(f func(*types.Address) bool) *StateAccessorSuicideCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *StateAccessorSuicideCall) DoAndReturn(f func(*types.Address) bool) *StateAccessorSuicideCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockIAccount is a mock of IAccount interface.
type MockIAccount struct {
	ctrl     *gomock.Controller
	recorder *MockIAccountMockRecorder
}

// MockIAccountMockRecorder is the mock recorder for MockIAccount.
type MockIAccountMockRecorder struct {
	mock *MockIAccount
}

// NewMockIAccount creates a new mock instance.
func NewMockIAccount(ctrl *gomock.Controller) *MockIAccount {
	mock := &MockIAccount{ctrl: ctrl}
	mock.recorder = &MockIAccountMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIAccount) EXPECT() *MockIAccountMockRecorder {
	return m.recorder
}

// AddBalance mocks base method.
func (m *MockIAccount) AddBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddBalance", amount)
}

// AddBalance indicates an expected call of AddBalance.
func (mr *MockIAccountMockRecorder) AddBalance(amount any) *IAccountAddBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBalance", reflect.TypeOf((*MockIAccount)(nil).AddBalance), amount)
	return &IAccountAddBalanceCall{Call: call}
}

// IAccountAddBalanceCall wrap *gomock.Call
type IAccountAddBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountAddBalanceCall) Return() *IAccountAddBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountAddBalanceCall) Do(f func(*big.Int)) *IAccountAddBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountAddBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountAddBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Code mocks base method.
func (m *MockIAccount) Code() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Code")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Code indicates an expected call of Code.
func (mr *MockIAccountMockRecorder) Code() *IAccountCodeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Code", reflect.TypeOf((*MockIAccount)(nil).Code))
	return &IAccountCodeCall{Call: call}
}

// IAccountCodeCall wrap *gomock.Call
type IAccountCodeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountCodeCall) Return(arg0 []byte) *IAccountCodeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountCodeCall) Do(f func() []byte) *IAccountCodeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountCodeCall) DoAndReturn(f func() []byte) *IAccountCodeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CodeHash mocks base method.
func (m *MockIAccount) CodeHash() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CodeHash")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// CodeHash indicates an expected call of CodeHash.
func (mr *MockIAccountMockRecorder) CodeHash() *IAccountCodeHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CodeHash", reflect.TypeOf((*MockIAccount)(nil).CodeHash))
	return &IAccountCodeHashCall{Call: call}
}

// IAccountCodeHashCall wrap *gomock.Call
type IAccountCodeHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountCodeHashCall) Return(arg0 []byte) *IAccountCodeHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountCodeHashCall) Do(f func() []byte) *IAccountCodeHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountCodeHashCall) DoAndReturn(f func() []byte) *IAccountCodeHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Finalise mocks base method.
func (m *MockIAccount) Finalise() [][]byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Finalise")
	ret0, _ := ret[0].([][]byte)
	return ret0
}

// Finalise indicates an expected call of Finalise.
func (mr *MockIAccountMockRecorder) Finalise() *IAccountFinaliseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalise", reflect.TypeOf((*MockIAccount)(nil).Finalise))
	return &IAccountFinaliseCall{Call: call}
}

// IAccountFinaliseCall wrap *gomock.Call
type IAccountFinaliseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountFinaliseCall) Return(arg0 [][]byte) *IAccountFinaliseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountFinaliseCall) Do(f func() [][]byte) *IAccountFinaliseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountFinaliseCall) DoAndReturn(f func() [][]byte) *IAccountFinaliseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAddress mocks base method.
func (m *MockIAccount) GetAddress() *types.Address {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddress")
	ret0, _ := ret[0].(*types.Address)
	return ret0
}

// GetAddress indicates an expected call of GetAddress.
func (mr *MockIAccountMockRecorder) GetAddress() *IAccountGetAddressCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddress", reflect.TypeOf((*MockIAccount)(nil).GetAddress))
	return &IAccountGetAddressCall{Call: call}
}

// IAccountGetAddressCall wrap *gomock.Call
type IAccountGetAddressCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetAddressCall) Return(arg0 *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetAddressCall) Do(f func() *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetAddressCall) DoAndReturn(f func() *types.Address) *IAccountGetAddressCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetBalance mocks base method.
func (m *MockIAccount) GetBalance() *big.Int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalance")
	ret0, _ := ret[0].(*big.Int)
	return ret0
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockIAccountMockRecorder) GetBalance() *IAccountGetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockIAccount)(nil).GetBalance))
	return &IAccountGetBalanceCall{Call: call}
}

// IAccountGetBalanceCall wrap *gomock.Call
type IAccountGetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetBalanceCall) Return(arg0 *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetBalanceCall) Do(f func() *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetBalanceCall) DoAndReturn(f func() *big.Int) *IAccountGetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetCommittedState mocks base method.
func (m *MockIAccount) GetCommittedState(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommittedState", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetCommittedState indicates an expected call of GetCommittedState.
func (mr *MockIAccountMockRecorder) GetCommittedState(key any) *IAccountGetCommittedStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommittedState", reflect.TypeOf((*MockIAccount)(nil).GetCommittedState), key)
	return &IAccountGetCommittedStateCall{Call: call}
}

// IAccountGetCommittedStateCall wrap *gomock.Call
type IAccountGetCommittedStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetCommittedStateCall) Return(arg0 []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetCommittedStateCall) Do(f func([]byte) []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetCommittedStateCall) DoAndReturn(f func([]byte) []byte) *IAccountGetCommittedStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetNonce mocks base method.
func (m *MockIAccount) GetNonce() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNonce")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetNonce indicates an expected call of GetNonce.
func (mr *MockIAccountMockRecorder) GetNonce() *IAccountGetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNonce", reflect.TypeOf((*MockIAccount)(nil).GetNonce))
	return &IAccountGetNonceCall{Call: call}
}

// IAccountGetNonceCall wrap *gomock.Call
type IAccountGetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetNonceCall) Return(arg0 uint64) *IAccountGetNonceCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetNonceCall) Do(f func() uint64) *IAccountGetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetNonceCall) DoAndReturn(f func() uint64) *IAccountGetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetState mocks base method.
func (m *MockIAccount) GetState(key []byte) (bool, []byte) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetState", key)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	return ret0, ret1
}

// GetState indicates an expected call of GetState.
func (mr *MockIAccountMockRecorder) GetState(key any) *IAccountGetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetState", reflect.TypeOf((*MockIAccount)(nil).GetState), key)
	return &IAccountGetStateCall{Call: call}
}

// IAccountGetStateCall wrap *gomock.Call
type IAccountGetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetStateCall) Return(arg0 bool, arg1 []byte) *IAccountGetStateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetStateCall) Do(f func([]byte) (bool, []byte)) *IAccountGetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetStateCall) DoAndReturn(f func([]byte) (bool, []byte)) *IAccountGetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStorageRoot mocks base method.
func (m *MockIAccount) GetStorageRoot() common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageRoot")
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetStorageRoot indicates an expected call of GetStorageRoot.
func (mr *MockIAccountMockRecorder) GetStorageRoot() *IAccountGetStorageRootCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageRoot", reflect.TypeOf((*MockIAccount)(nil).GetStorageRoot))
	return &IAccountGetStorageRootCall{Call: call}
}

// IAccountGetStorageRootCall wrap *gomock.Call
type IAccountGetStorageRootCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetStorageRootCall) Return(arg0 common.Hash) *IAccountGetStorageRootCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetStorageRootCall) Do(f func() common.Hash) *IAccountGetStorageRootCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetStorageRootCall) DoAndReturn(f func() common.Hash) *IAccountGetStorageRootCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStorageRootHash mocks base method.
func (m *MockIAccount) GetStorageRootHash() common.Hash {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageRootHash")
	ret0, _ := ret[0].(common.Hash)
	return ret0
}

// GetStorageRootHash indicates an expected call of GetStorageRootHash.
func (mr *MockIAccountMockRecorder) GetStorageRootHash() *IAccountGetStorageRootHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageRootHash", reflect.TypeOf((*MockIAccount)(nil).GetStorageRootHash))
	return &IAccountGetStorageRootHashCall{Call: call}
}

// IAccountGetStorageRootHashCall wrap *gomock.Call
type IAccountGetStorageRootHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountGetStorageRootHashCall) Return(arg0 common.Hash) *IAccountGetStorageRootHashCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountGetStorageRootHashCall) Do(f func() common.Hash) *IAccountGetStorageRootHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountGetStorageRootHashCall) DoAndReturn(f func() common.Hash) *IAccountGetStorageRootHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsEmpty mocks base method.
func (m *MockIAccount) IsEmpty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty.
func (mr *MockIAccountMockRecorder) IsEmpty() *IAccountIsEmptyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*MockIAccount)(nil).IsEmpty))
	return &IAccountIsEmptyCall{Call: call}
}

// IAccountIsEmptyCall wrap *gomock.Call
type IAccountIsEmptyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountIsEmptyCall) Return(arg0 bool) *IAccountIsEmptyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountIsEmptyCall) Do(f func() bool) *IAccountIsEmptyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountIsEmptyCall) DoAndReturn(f func() bool) *IAccountIsEmptyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetBalance mocks base method.
func (m *MockIAccount) SetBalance(balance *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetBalance", balance)
}

// SetBalance indicates an expected call of SetBalance.
func (mr *MockIAccountMockRecorder) SetBalance(balance any) *IAccountSetBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBalance", reflect.TypeOf((*MockIAccount)(nil).SetBalance), balance)
	return &IAccountSetBalanceCall{Call: call}
}

// IAccountSetBalanceCall wrap *gomock.Call
type IAccountSetBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetBalanceCall) Return() *IAccountSetBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetBalanceCall) Do(f func(*big.Int)) *IAccountSetBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountSetBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetCodeAndHash mocks base method.
func (m *MockIAccount) SetCodeAndHash(code []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetCodeAndHash", code)
}

// SetCodeAndHash indicates an expected call of SetCodeAndHash.
func (mr *MockIAccountMockRecorder) SetCodeAndHash(code any) *IAccountSetCodeAndHashCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCodeAndHash", reflect.TypeOf((*MockIAccount)(nil).SetCodeAndHash), code)
	return &IAccountSetCodeAndHashCall{Call: call}
}

// IAccountSetCodeAndHashCall wrap *gomock.Call
type IAccountSetCodeAndHashCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetCodeAndHashCall) Return() *IAccountSetCodeAndHashCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetCodeAndHashCall) Do(f func([]byte)) *IAccountSetCodeAndHashCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetCodeAndHashCall) DoAndReturn(f func([]byte)) *IAccountSetCodeAndHashCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetEnableExpensiveMetric mocks base method.
func (m *MockIAccount) SetEnableExpensiveMetric(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetEnableExpensiveMetric", arg0)
}

// SetEnableExpensiveMetric indicates an expected call of SetEnableExpensiveMetric.
func (mr *MockIAccountMockRecorder) SetEnableExpensiveMetric(arg0 any) *IAccountSetEnableExpensiveMetricCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetEnableExpensiveMetric", reflect.TypeOf((*MockIAccount)(nil).SetEnableExpensiveMetric), arg0)
	return &IAccountSetEnableExpensiveMetricCall{Call: call}
}

// IAccountSetEnableExpensiveMetricCall wrap *gomock.Call
type IAccountSetEnableExpensiveMetricCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetEnableExpensiveMetricCall) Return() *IAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetEnableExpensiveMetricCall) Do(f func(bool)) *IAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetEnableExpensiveMetricCall) DoAndReturn(f func(bool)) *IAccountSetEnableExpensiveMetricCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetNonce mocks base method.
func (m *MockIAccount) SetNonce(nonce uint64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetNonce", nonce)
}

// SetNonce indicates an expected call of SetNonce.
func (mr *MockIAccountMockRecorder) SetNonce(nonce any) *IAccountSetNonceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNonce", reflect.TypeOf((*MockIAccount)(nil).SetNonce), nonce)
	return &IAccountSetNonceCall{Call: call}
}

// IAccountSetNonceCall wrap *gomock.Call
type IAccountSetNonceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetNonceCall) Return() *IAccountSetNonceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetNonceCall) Do(f func(uint64)) *IAccountSetNonceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetNonceCall) DoAndReturn(f func(uint64)) *IAccountSetNonceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockIAccount) SetState(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetState", key, value)
}

// SetState indicates an expected call of SetState.
func (mr *MockIAccountMockRecorder) SetState(key, value any) *IAccountSetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockIAccount)(nil).SetState), key, value)
	return &IAccountSetStateCall{Call: call}
}

// IAccountSetStateCall wrap *gomock.Call
type IAccountSetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetStateCall) Return() *IAccountSetStateCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetStateCall) Do(f func([]byte, []byte)) *IAccountSetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetStateCall) DoAndReturn(f func([]byte, []byte)) *IAccountSetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSuicided mocks base method.
func (m *MockIAccount) SetSuicided(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetSuicided", arg0)
}

// SetSuicided indicates an expected call of SetSuicided.
func (mr *MockIAccountMockRecorder) SetSuicided(arg0 any) *IAccountSetSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSuicided", reflect.TypeOf((*MockIAccount)(nil).SetSuicided), arg0)
	return &IAccountSetSuicidedCall{Call: call}
}

// IAccountSetSuicidedCall wrap *gomock.Call
type IAccountSetSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSetSuicidedCall) Return() *IAccountSetSuicidedCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSetSuicidedCall) Do(f func(bool)) *IAccountSetSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSetSuicidedCall) DoAndReturn(f func(bool)) *IAccountSetSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// String mocks base method.
func (m *MockIAccount) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockIAccountMockRecorder) String() *IAccountStringCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockIAccount)(nil).String))
	return &IAccountStringCall{Call: call}
}

// IAccountStringCall wrap *gomock.Call
type IAccountStringCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountStringCall) Return(arg0 string) *IAccountStringCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountStringCall) Do(f func() string) *IAccountStringCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountStringCall) DoAndReturn(f func() string) *IAccountStringCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SubBalance mocks base method.
func (m *MockIAccount) SubBalance(amount *big.Int) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubBalance", amount)
}

// SubBalance indicates an expected call of SubBalance.
func (mr *MockIAccountMockRecorder) SubBalance(amount any) *IAccountSubBalanceCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubBalance", reflect.TypeOf((*MockIAccount)(nil).SubBalance), amount)
	return &IAccountSubBalanceCall{Call: call}
}

// IAccountSubBalanceCall wrap *gomock.Call
type IAccountSubBalanceCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSubBalanceCall) Return() *IAccountSubBalanceCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSubBalanceCall) Do(f func(*big.Int)) *IAccountSubBalanceCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSubBalanceCall) DoAndReturn(f func(*big.Int)) *IAccountSubBalanceCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Suicided mocks base method.
func (m *MockIAccount) Suicided() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Suicided")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Suicided indicates an expected call of Suicided.
func (mr *MockIAccountMockRecorder) Suicided() *IAccountSuicidedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Suicided", reflect.TypeOf((*MockIAccount)(nil).Suicided))
	return &IAccountSuicidedCall{Call: call}
}

// IAccountSuicidedCall wrap *gomock.Call
type IAccountSuicidedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *IAccountSuicidedCall) Return(arg0 bool) *IAccountSuicidedCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *IAccountSuicidedCall) Do(f func() bool) *IAccountSuicidedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *IAccountSuicidedCall) DoAndReturn(f func() bool) *IAccountSuicidedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
